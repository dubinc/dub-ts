// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package server

import (
	"bytes"
	"context"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"path/filepath"
	"strings"
)

const (
	// Mock server internal route prefix to prevent naming collisions.
	internalPathPrefix = "/_mockserver"
)

// registerInternalHandlers adds any internal handlers, such as healthcheck
// endpoints and fallback handling.
func (s *Server) registerInternalHandlers(ctx context.Context) {
	s.logger.Debug("registering internal handlers")

	// Healthcheck endpoint
	s.RegisterHandlerFunc(ctx, []string{http.MethodGet}, internalPathPrefix+"/health", healthcheckHandler)

	// HTTP log index endpoint
	s.RegisterHandlerFunc(ctx, []string{http.MethodGet}, internalPathPrefix+"/log", s.httpFileIndexHandler)

	// HTTP log operation endpoint
	s.RegisterHandlerFunc(ctx, []string{http.MethodGet}, internalPathPrefix+"/log/{operationId}", s.httpOperationHandler)

	// Default all other requests to 404 Not Found
	s.RegisterHandlerFunc(ctx, []string{}, "/", rootHandler)
}

// healthcheckHandler returns a simple OK response.
func healthcheckHandler(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "OK")
}

// httpFileIndexHandler returns a HTML index page for all logged HTTP operations
// written to the HTTP file directory.
func (s *Server) httpFileIndexHandler(w http.ResponseWriter, _ *http.Request) {
	operations, err := s.httpFileDir.Operations()

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation log error: %s", err),
			http.StatusInternalServerError,
		)

		return
	}

	type operationModel struct {
		CallCount int64
		ID        string
		LogURL    string
		Method    string
		Path      string
	}

	type indexModel struct {
		Operations []operationModel
	}

	var index indexModel

	for _, operation := range operations {
		index.Operations = append(index.Operations, operationModel{
			CallCount: operation.CallCount(),
			ID:        operation.Id(),
			LogURL:    internalPathPrefix + "/log/" + operation.Id(),
			Method:    operation.Method(),
			Path:      operation.Path(),
		})
	}

	tmpl := template.New("index.html.tmpl")
	tmpl.Funcs(template.FuncMap{
		"mod": func(i, j int) bool { return i%j == 0 },
	})
	_, err = tmpl.ParseFiles(
		filepath.Join("internal", "server", "templates", "log", "style.css.tmpl"),
		filepath.Join("internal", "server", "templates", "log", "index.html.tmpl"),
	)

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation log template error: %s", err),
			http.StatusInternalServerError,
		)

		return
	}

	var wBuf bytes.Buffer

	err = tmpl.Execute(&wBuf, index)

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation log template execution error: %s", err),
			http.StatusInternalServerError,
		)

		return
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	_, _ = wBuf.WriteTo(w)
}

// httpOperationHandler returns a HTML page for HTTP request and response log files
// written to _debug.
func (s *Server) httpOperationHandler(w http.ResponseWriter, req *http.Request) {
	operationId := req.PathValue("operationId")

	if operationId == "" {
		http.Error(w, "operation logs not found", http.StatusNotFound)

		return
	}

	operation, err := s.httpFileDir.Operation(operationId)

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation %s log error: %s", operationId, err),
			http.StatusInternalServerError,
		)

		return
	}

	type headerModel struct {
		Key    string
		Values template.HTML
	}

	type queryParameterModel struct {
		Key    string
		Values template.HTML
	}

	type operationCallModel struct {
		Call            int64
		ID              string
		LogOperationURL string

		RawRequest  template.HTML
		RawResponse template.HTML

		RequestBody            string
		RequestHeaders         []headerModel
		RequestQueryParameters []queryParameterModel

		ResponseBody    string
		ResponseHeaders []headerModel
		ResponseStatus  string
	}

	type operationDataModel struct {
		Calls         []operationCallModel
		ID            string
		LogIndexURL   string
		RequestMethod string
		RequestPath   string
	}

	operationData := operationDataModel{
		ID:            operationId,
		LogIndexURL:   internalPathPrefix + "/log",
		RequestMethod: operation.Method(),
		RequestPath:   operation.Path(),
	}

	for i := range operation.CallCount() {
		call := i + 1

		callReqRaw, err := operation.RawRequest(call)

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log raw request error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		callReq, err := operation.Request(call)

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log request error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		callReqBody, err := io.ReadAll(callReq.Body)
		defer callReq.Body.Close()

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log request body error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		callRespRaw, err := operation.RawResponse(call)

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log response error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		callResp, err := operation.Response(call)

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log response error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		callRespBody, err := io.ReadAll(callResp.Body)
		defer callReq.Body.Close()

		if err != nil {
			http.Error(
				w,
				fmt.Sprintf("operation %s call %d log response body error: %s", operationId, call, err),
				http.StatusInternalServerError,
			)

			return
		}

		operationCall := operationCallModel{
			Call:            call,
			LogOperationURL: internalPathPrefix + "/log/" + operationId,

			RawRequest:  template.HTML(strings.ReplaceAll(string(callReqRaw), "\r\n", "<br>")),
			RawResponse: template.HTML(strings.ReplaceAll(string(callRespRaw), "\r\n", "<br>")),

			RequestBody:    string(callReqBody),
			ResponseBody:   string(callRespBody),
			ResponseStatus: callResp.Status,
		}

		for key, values := range callReq.URL.Query() {
			operationCall.RequestQueryParameters = append(operationCall.RequestQueryParameters, queryParameterModel{
				Key:    key,
				Values: template.HTML(strings.Join(values, "<br>")),
			})
		}

		for key, values := range callReq.Header {
			operationCall.RequestHeaders = append(operationCall.RequestHeaders, headerModel{
				Key:    key,
				Values: template.HTML(strings.Join(values, "<br>")),
			})
		}

		for key, values := range callResp.Header {
			operationCall.ResponseHeaders = append(operationCall.ResponseHeaders, headerModel{
				Key:    key,
				Values: template.HTML(strings.Join(values, "<br>")),
			})
		}

		operationData.Calls = append(operationData.Calls, operationCall)
	}

	tmpl := template.New("operation.html.tmpl")
	tmpl.Funcs(template.FuncMap{
		"mod": func(i, j int) bool { return i%j == 0 },
	})
	_, err = tmpl.ParseFiles(
		filepath.Join("internal", "server", "templates", "log", "style.css.tmpl"),
		filepath.Join("internal", "server", "templates", "log", "operation.html.tmpl"),
	)

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation log template error: %s", err),
			http.StatusInternalServerError,
		)

		return
	}

	var wBuf bytes.Buffer

	err = tmpl.Execute(&wBuf, operationData)

	if err != nil {
		http.Error(
			w,
			fmt.Sprintf("operation log template execution error: %s", err),
			http.StatusInternalServerError,
		)

		return
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	_, _ = wBuf.WriteTo(w)
}

// rootHandler returns a slightly customized [http.NotFoundHandler], saying
// "path" instead of "page".
func rootHandler(w http.ResponseWriter, _ *http.Request) {
	http.Error(w, "path not found", http.StatusNotFound)
}
