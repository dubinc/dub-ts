// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package logging

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"net/http/httptest"
	"net/http/httputil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
)

const (
	// DefaultHTTPFileDirectory is the default directory used for raw HTTP
	// request and response files.
	DefaultHTTPFileDirectory = "_debug"
)

// HTTPFileDirectory is the directory where raw HTTP request and response files
// are written.
type HTTPFileDirectory struct {
	// Filesystem at path.
	filesystem fs.FS

	// Mapping of operations to call count. Used to sequentially increment file
	// names and return current count.
	operationCalls map[string]int64

	// Mutex to protect operationCalls.
	operationCallsMutex *sync.RWMutex

	// Absolute path to directory.
	path string
}

// NewHTTPFileDirectory will create a HTTPFileDirectory which exists and is a
// directory or will return an error.
func NewHTTPFileDirectory(explicitPath string) (*HTTPFileDirectory, error) {
	path, err := filepath.Abs(DefaultHTTPFileDirectory)
	if err != nil {
		return nil, fmt.Errorf("error getting absolute path of HTTP file directory (%s): %w", DefaultHTTPFileDirectory, err)
	}

	if explicitPath != "" {
		absExplicitPath, err := filepath.Abs(explicitPath)
		if err != nil {
			return nil, fmt.Errorf("error getting absolute path of HTTP file directory (%s):  %w", explicitPath, err)
		}

		path = absExplicitPath
	}

	result := &HTTPFileDirectory{
		filesystem:          os.DirFS(path),
		operationCalls:      make(map[string]int64),
		operationCallsMutex: new(sync.RWMutex),
		path:                path,
	}

	fileInfo, err := os.Stat(path)

	if errors.Is(err, os.ErrNotExist) {
		err := os.Mkdir(path, 0o2777)
		if err != nil {
			return nil, fmt.Errorf("error making HTTP file directory (%s): %w", path, err)
		}

		return result, nil
	}

	if err != nil {
		return nil, fmt.Errorf("error reading HTTP file directory (%s): %w", path, err)
	}

	if !fileInfo.IsDir() {
		return nil, fmt.Errorf("error using HTTP file directory (%s): not a directory", path)
	}

	return result, nil
}

// Clean will remove all files from HTTPFileDirectory.
func (d *HTTPFileDirectory) Clean() error {
	walkDirFunc := func(path string, entry fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("error walking %s: %w", d.path, err)
		}

		if path == "." {
			return nil
		}

		if entry.IsDir() {
			return fs.SkipDir
		}

		absPath := filepath.Join(d.path, path)

		err = os.Remove(absPath)
		if err != nil {
			return fmt.Errorf("error removing %s: %w", absPath, err)
		}

		return nil
	}

	return fs.WalkDir(d.filesystem, ".", walkDirFunc)
}

// HandlerFunc is a HTTP handler that automatically writes the raw HTTP
// request and response to {path}/{operationId}_{call}_request and
// {path}/{operationId}_{call}_response files respectively.
func (d *HTTPFileDirectory) HandlerFunc(operationId string, next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		call := d.nextOperationCall(operationId)

		dump, err := httputil.DumpRequest(req, true)
		if err != nil {
			log.Printf("error dumping HTTP request: %s", err)
		}

		if len(dump) > 0 {
			requestPath := filepath.Join(d.path, d.operationCallRequestFilename(operationId, call))

			err = os.WriteFile(requestPath, dump, 0o644)
			if err != nil {
				log.Printf("error writing HTTP request file (%s): %s", requestPath, err)
			}
		}

		recorder := httptest.NewRecorder()

		next(recorder, req)

		dump, err = httputil.DumpResponse(recorder.Result(), true)
		if err != nil {
			log.Printf("error dumping HTTP response: %s", err)
		}

		if len(dump) > 0 {
			responsePath := filepath.Join(d.path, d.operationCallResponseFilename(operationId, call))
			err = os.WriteFile(responsePath, dump, 0o644)
			if err != nil {
				log.Printf("error writing HTTP response file (%s): %s", responsePath, err)
			}
		}

		recorderToWriter(recorder, w)
	}
}

// Operation will return a new OASOperation from HTTPFileDirectory.
func (d *HTTPFileDirectory) Operation(operationId string) (*OASOperation, error) {
	request, err := d.Request(operationId, 1)
	if err != nil {
		return nil, err
	}

	result := NewOASOperation(d, operationId, request.Method, request.URL.Path)

	return result, nil
}

// Operations will return all detected OASOperation from HTTPFileDirectory.
func (d *HTTPFileDirectory) Operations() ([]*OASOperation, error) {
	var result []*OASOperation

	walkDirFunc := func(path string, entry fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("error walking %s: %w", d.path, err)
		}

		if !strings.HasSuffix(path, "_1_request") {
			return nil
		}

		operationId := strings.TrimSuffix(path, "_1_request")
		operation, err := d.Operation(operationId)
		if err != nil {
			return err
		}

		result = append(result, operation)

		return nil
	}

	err := fs.WalkDir(d.filesystem, ".", walkDirFunc)

	return result, err
}

// OperationCallCount will return the number of detected calls for an
// OASOperation.
func (d *HTTPFileDirectory) OperationCallCount(operationId string) int64 {
	d.operationCallsMutex.RLock()
	defer d.operationCallsMutex.RUnlock()

	result, ok := d.operationCalls[operationId]

	if ok {
		return result
	}

	return 0
}

// RawRequest returns the raw HTTP request contents as dumped by
// [httputil.DumpRequest].
func (d *HTTPFileDirectory) RawRequest(operationId string, call int64) ([]byte, error) {
	filename := d.operationCallRequestFilename(operationId, call)
	file, err := fs.ReadFile(d.filesystem, filename)
	if err != nil {
		return nil, fmt.Errorf("error reading HTTP request file (%s): %w", filename, err)
	}

	return file, nil
}

// RawResponse returns the raw HTTP response contents as dumped by
// [httputil.DumpResponse].
func (d *HTTPFileDirectory) RawResponse(operationId string, call int64) ([]byte, error) {
	filename := d.operationCallResponseFilename(operationId, call)
	file, err := fs.ReadFile(d.filesystem, d.operationCallResponseFilename(operationId, call))
	if err != nil {
		return nil, fmt.Errorf("error reading HTTP response file (%s): %w", filename, err)
	}

	return file, nil
}

// Request returns the parsed HTTP request contents.
func (d *HTTPFileDirectory) Request(operationId string, call int64) (*http.Request, error) {
	rawRequest, err := d.RawRequest(operationId, call)
	if err != nil {
		return nil, err
	}

	result, err := http.ReadRequest(bufio.NewReader(bytes.NewReader(rawRequest)))
	if err != nil {
		return nil, fmt.Errorf("error converting HTTP request for operation %s call %d: %w", operationId, call, err)
	}

	return result, nil
}

// Response returns the parsed HTTP response contents.
func (d *HTTPFileDirectory) Response(operationId string, call int64) (*http.Response, error) {
	rawResponse, err := d.RawResponse(operationId, call)
	if err != nil {
		return nil, err
	}

	result, err := http.ReadResponse(bufio.NewReader(bytes.NewReader(rawResponse)), nil)
	if err != nil {
		return nil, fmt.Errorf("error converting HTTP response for operation %s call %d: %w", operationId, call, err)
	}

	return result, nil
}

// nextOperationCall returns the incremented call number for an operation.
func (d *HTTPFileDirectory) nextOperationCall(operationId string) int64 {
	d.operationCallsMutex.Lock()
	defer d.operationCallsMutex.Unlock()

	var result int64

	priorCalls, ok := d.operationCalls[operationId]

	if ok {
		result = priorCalls + 1
	} else {
		// Start call counts at 1 for human consumption.
		result = 1
	}

	d.operationCalls[operationId] = result

	return result
}

// operationCallRequestFilename returns the raw HTTP request file name for the
// given operation and call.
func (d *HTTPFileDirectory) operationCallRequestFilename(operationId string, call int64) string {
	return sanitizeOperationIdForFilename(operationId) + "_" + strconv.FormatInt(call, 10) + "_request"
}

// operationCallResponseFilename returns the raw HTTP response file name for the
// given operation and call.
func (d *HTTPFileDirectory) operationCallResponseFilename(operationId string, call int64) string {
	return sanitizeOperationIdForFilename(operationId) + "_" + strconv.FormatInt(call, 10) + "_response"
}

func sanitizeOperationIdForFilename(operationId string) string {
	operationId = strings.ReplaceAll(operationId, "{", "_")
	operationId = strings.ReplaceAll(operationId, "}", "_")
	operationId = strings.ReplaceAll(operationId, "/", "_")
	operationId = strings.ReplaceAll(operationId, " ", "_")
	return operationId
}
