/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  LinkTagSchema,
  LinkTagSchema$inboundSchema,
  LinkTagSchema$Outbound,
  LinkTagSchema$outboundSchema,
} from "./linktagschema.js";

export const SaleCreatedEventEvent = {
  SaleCreated: "sale.created",
} as const;
export type SaleCreatedEventEvent = ClosedEnum<typeof SaleCreatedEventEvent>;

export type SaleCreatedEventCustomer = {
  /**
   * The unique ID of the customer. You may use either the customer's `id` on Dub (obtained via `/customers` endpoint) or their `externalId` (unique ID within your system, prefixed with `ext_`, e.g. `ext_123`).
   */
  id: string;
  /**
   * Name of the customer.
   */
  name: string;
  /**
   * Email of the customer.
   */
  email?: string | null | undefined;
  /**
   * Avatar URL of the customer.
   */
  avatar?: string | null | undefined;
  /**
   * Unique identifier for the customer in the client's app.
   */
  externalId: string;
  /**
   * The customer's Stripe customer ID. This is useful for attributing recurring sale events to the partner who referred the customer.
   */
  stripeCustomerId?: string | null | undefined;
  /**
   * Country of the customer.
   */
  country?: string | null | undefined;
  /**
   * Total number of sales for the customer.
   */
  sales?: number | null | undefined;
  /**
   * Total amount of sales for the customer.
   */
  saleAmount?: number | null | undefined;
  /**
   * The date the customer was created (usually the signup date or trial start date).
   */
  createdAt: string;
  /**
   * The date the customer made their first sale. Useful for calculating the time to first sale and LTV.
   */
  firstSaleAt?: string | null | undefined;
  /**
   * The date the customer canceled their subscription. Useful for calculating LTV and churn rate.
   */
  subscriptionCanceledAt?: string | null | undefined;
};

export type SaleCreatedEventClick = {
  id: string;
  timestamp: string;
  url: string;
  country: string;
  city: string;
  region: string;
  continent: string;
  device: string;
  browser: string;
  os: string;
  trigger?: string | null | undefined;
  referer: string;
  refererUrl: string;
  qr: boolean;
  ip: string;
};

export type SaleCreatedEventTestVariants = {
  url: string;
  percentage: number;
};

export type SaleCreatedEventLink = {
  /**
   * The unique ID of the short link.
   */
  id: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `dub.sh` if the workspace has no domains).
   */
  domain: string;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key: string;
  url: string;
  trackConversion: boolean;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId: string | null;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId: string | null;
  /**
   * The ID of the program the short link is associated with.
   */
  programId: string | null;
  /**
   * The ID of the partner the short link is associated with.
   */
  partnerId: string | null;
  archived: boolean;
  expiresAt: string;
  expiredUrl: string | null;
  disabledAt: string;
  /**
   * The password required to access the destination URL of the short link.
   */
  password: string | null;
  proxy: boolean;
  /**
   * The title of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  title: string | null;
  /**
   * The description of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  description: string | null;
  /**
   * The image of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  image: string | null;
  /**
   * The custom link preview video (og:video). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  video: string | null;
  rewrite: boolean;
  doIndex: boolean;
  /**
   * The iOS destination URL for the short link for iOS device targeting.
   */
  ios: string | null;
  /**
   * The Android destination URL for the short link for Android device targeting.
   */
  android: string | null;
  /**
   * Geo targeting information for the short link in JSON format `{[COUNTRY]: https://example.com }`. See https://d.to/geo for more information.
   */
  geo: { [k: string]: string } | null;
  publicStats: boolean;
  /**
   * The tags assigned to the short link.
   */
  tags: Array<LinkTagSchema> | null;
  /**
   * The unique ID of the folder assigned to the short link.
   */
  folderId: string | null;
  /**
   * The IDs of the webhooks that the short link is associated with.
   */
  webhookIds: Array<string>;
  /**
   * The comments for the short link.
   */
  comments: string | null;
  /**
   * The full URL of the short link, including the https protocol (e.g. `https://dub.sh/try`).
   */
  shortLink: string;
  /**
   * The full URL of the QR code for the short link (e.g. `https://api.dub.co/qr?url=https://dub.sh/try`).
   */
  qrCode: string;
  /**
   * The UTM source of the short link.
   */
  utmSource: string | null;
  /**
   * The UTM medium of the short link.
   */
  utmMedium: string | null;
  /**
   * The UTM campaign of the short link.
   */
  utmCampaign: string | null;
  /**
   * The UTM term of the short link.
   */
  utmTerm: string | null;
  /**
   * The UTM content of the short link.
   */
  utmContent: string | null;
  /**
   * An array of A/B test URLs and the percentage of traffic to send to each URL.
   */
  testVariants?: Array<SaleCreatedEventTestVariants> | null | undefined;
  testStartedAt: string;
  testCompletedAt: string;
  userId: string | null;
  /**
   * The workspace ID of the short link.
   */
  workspaceId: string;
  /**
   * The number of clicks on the short link.
   */
  clicks?: number | undefined;
  /**
   * The number of leads the short link has generated.
   */
  leads?: number | undefined;
  /**
   * The number of leads that converted to paying customers.
   */
  conversions?: number | undefined;
  /**
   * The total number of sales (includes recurring sales) generated by the short link.
   */
  sales?: number | undefined;
  /**
   * The total dollar value of sales (in cents) generated by the short link.
   */
  saleAmount?: number | undefined;
  lastClicked: string;
  createdAt: string;
  updatedAt: string;
  /**
   * Deprecated: Use `tags` instead. The unique ID of the tag assigned to the short link.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  tagId: string | null;
  /**
   * Deprecated: Use `workspaceId` instead. The project ID of the short link.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  projectId: string;
};

export type Sale = {
  amount: number;
  currency: string;
  paymentProcessor: string;
  invoiceId: string | null;
};

export type SaleCreatedEventPartner = {
  /**
   * The partner's unique ID on Dub.
   */
  id: string;
  /**
   * The partner's full legal name.
   */
  name: string;
  /**
   * The partner's email address. Should be a unique value across Dub.
   */
  email: string | null;
  /**
   * The partner's avatar image.
   */
  image: string | null;
  /**
   * The date when the partner enabled payouts.
   */
  payoutsEnabledAt: string | null;
  /**
   * The partner's country (required for tax purposes).
   */
  country: string | null;
  groupId?: string | null | undefined;
  totalClicks: number;
  totalLeads: number;
  totalConversions: number;
  totalSales: number;
  totalSaleAmount: number;
  totalCommissions: number;
};

export type SaleCreatedEventData = {
  eventName: string;
  customer: SaleCreatedEventCustomer;
  click: SaleCreatedEventClick;
  link: SaleCreatedEventLink;
  sale: Sale;
  partner?: SaleCreatedEventPartner | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
};

/**
 * Triggered when a sale is created.
 */
export type SaleCreatedEvent = {
  id: string;
  event: SaleCreatedEventEvent;
  createdAt: string;
  data: SaleCreatedEventData;
};

/** @internal */
export const SaleCreatedEventEvent$inboundSchema: z.ZodNativeEnum<
  typeof SaleCreatedEventEvent
> = z.nativeEnum(SaleCreatedEventEvent);
/** @internal */
export const SaleCreatedEventEvent$outboundSchema: z.ZodNativeEnum<
  typeof SaleCreatedEventEvent
> = SaleCreatedEventEvent$inboundSchema;

/** @internal */
export const SaleCreatedEventCustomer$inboundSchema: z.ZodType<
  SaleCreatedEventCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  externalId: z.string(),
  stripeCustomerId: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  sales: z.nullable(z.number()).optional(),
  saleAmount: z.nullable(z.number()).optional(),
  createdAt: z.string(),
  firstSaleAt: z.nullable(z.string()).optional(),
  subscriptionCanceledAt: z.nullable(z.string()).optional(),
});
/** @internal */
export type SaleCreatedEventCustomer$Outbound = {
  id: string;
  name: string;
  email?: string | null | undefined;
  avatar?: string | null | undefined;
  externalId: string;
  stripeCustomerId?: string | null | undefined;
  country?: string | null | undefined;
  sales?: number | null | undefined;
  saleAmount?: number | null | undefined;
  createdAt: string;
  firstSaleAt?: string | null | undefined;
  subscriptionCanceledAt?: string | null | undefined;
};

/** @internal */
export const SaleCreatedEventCustomer$outboundSchema: z.ZodType<
  SaleCreatedEventCustomer$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventCustomer
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  externalId: z.string(),
  stripeCustomerId: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  sales: z.nullable(z.number()).optional(),
  saleAmount: z.nullable(z.number()).optional(),
  createdAt: z.string(),
  firstSaleAt: z.nullable(z.string()).optional(),
  subscriptionCanceledAt: z.nullable(z.string()).optional(),
});

export function saleCreatedEventCustomerToJSON(
  saleCreatedEventCustomer: SaleCreatedEventCustomer,
): string {
  return JSON.stringify(
    SaleCreatedEventCustomer$outboundSchema.parse(saleCreatedEventCustomer),
  );
}
export function saleCreatedEventCustomerFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventCustomer' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEventClick$inboundSchema: z.ZodType<
  SaleCreatedEventClick,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  timestamp: z.string(),
  url: z.string(),
  country: z.string(),
  city: z.string(),
  region: z.string(),
  continent: z.string(),
  device: z.string(),
  browser: z.string(),
  os: z.string(),
  trigger: z.nullable(z.string()).optional(),
  referer: z.string(),
  refererUrl: z.string(),
  qr: z.boolean(),
  ip: z.string(),
});
/** @internal */
export type SaleCreatedEventClick$Outbound = {
  id: string;
  timestamp: string;
  url: string;
  country: string;
  city: string;
  region: string;
  continent: string;
  device: string;
  browser: string;
  os: string;
  trigger?: string | null | undefined;
  referer: string;
  refererUrl: string;
  qr: boolean;
  ip: string;
};

/** @internal */
export const SaleCreatedEventClick$outboundSchema: z.ZodType<
  SaleCreatedEventClick$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventClick
> = z.object({
  id: z.string(),
  timestamp: z.string(),
  url: z.string(),
  country: z.string(),
  city: z.string(),
  region: z.string(),
  continent: z.string(),
  device: z.string(),
  browser: z.string(),
  os: z.string(),
  trigger: z.nullable(z.string()).optional(),
  referer: z.string(),
  refererUrl: z.string(),
  qr: z.boolean(),
  ip: z.string(),
});

export function saleCreatedEventClickToJSON(
  saleCreatedEventClick: SaleCreatedEventClick,
): string {
  return JSON.stringify(
    SaleCreatedEventClick$outboundSchema.parse(saleCreatedEventClick),
  );
}
export function saleCreatedEventClickFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventClick, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventClick$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventClick' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEventTestVariants$inboundSchema: z.ZodType<
  SaleCreatedEventTestVariants,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  percentage: z.number(),
});
/** @internal */
export type SaleCreatedEventTestVariants$Outbound = {
  url: string;
  percentage: number;
};

/** @internal */
export const SaleCreatedEventTestVariants$outboundSchema: z.ZodType<
  SaleCreatedEventTestVariants$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventTestVariants
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

export function saleCreatedEventTestVariantsToJSON(
  saleCreatedEventTestVariants: SaleCreatedEventTestVariants,
): string {
  return JSON.stringify(
    SaleCreatedEventTestVariants$outboundSchema.parse(
      saleCreatedEventTestVariants,
    ),
  );
}
export function saleCreatedEventTestVariantsFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventTestVariants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventTestVariants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventTestVariants' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEventLink$inboundSchema: z.ZodType<
  SaleCreatedEventLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean(),
  externalId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  partnerId: z.nullable(z.string()),
  archived: z.boolean(),
  expiresAt: z.string(),
  expiredUrl: z.nullable(z.string()),
  disabledAt: z.string(),
  password: z.nullable(z.string()),
  proxy: z.boolean(),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  rewrite: z.boolean(),
  doIndex: z.boolean(),
  ios: z.nullable(z.string()),
  android: z.nullable(z.string()),
  geo: z.nullable(z.record(z.string())),
  publicStats: z.boolean(),
  tags: z.nullable(z.array(LinkTagSchema$inboundSchema)),
  folderId: z.nullable(z.string()),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utm_source: z.nullable(z.string()),
  utm_medium: z.nullable(z.string()),
  utm_campaign: z.nullable(z.string()),
  utm_term: z.nullable(z.string()),
  utm_content: z.nullable(z.string()),
  testVariants: z.nullable(
    z.array(z.lazy(() => SaleCreatedEventTestVariants$inboundSchema)),
  ).optional(),
  testStartedAt: z.string(),
  testCompletedAt: z.string(),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  leads: z.number().default(0),
  conversions: z.number().default(0),
  sales: z.number().default(0),
  saleAmount: z.number().default(0),
  lastClicked: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  tagId: z.nullable(z.string()),
  projectId: z.string(),
}).transform((v) => {
  return remap$(v, {
    "utm_source": "utmSource",
    "utm_medium": "utmMedium",
    "utm_campaign": "utmCampaign",
    "utm_term": "utmTerm",
    "utm_content": "utmContent",
  });
});
/** @internal */
export type SaleCreatedEventLink$Outbound = {
  id: string;
  domain: string;
  key: string;
  url: string;
  trackConversion: boolean;
  externalId: string | null;
  tenantId: string | null;
  programId: string | null;
  partnerId: string | null;
  archived: boolean;
  expiresAt: string;
  expiredUrl: string | null;
  disabledAt: string;
  password: string | null;
  proxy: boolean;
  title: string | null;
  description: string | null;
  image: string | null;
  video: string | null;
  rewrite: boolean;
  doIndex: boolean;
  ios: string | null;
  android: string | null;
  geo: { [k: string]: string } | null;
  publicStats: boolean;
  tags: Array<LinkTagSchema$Outbound> | null;
  folderId: string | null;
  webhookIds: Array<string>;
  comments: string | null;
  shortLink: string;
  qrCode: string;
  utm_source: string | null;
  utm_medium: string | null;
  utm_campaign: string | null;
  utm_term: string | null;
  utm_content: string | null;
  testVariants?:
    | Array<SaleCreatedEventTestVariants$Outbound>
    | null
    | undefined;
  testStartedAt: string;
  testCompletedAt: string;
  userId: string | null;
  workspaceId: string;
  clicks: number;
  leads: number;
  conversions: number;
  sales: number;
  saleAmount: number;
  lastClicked: string;
  createdAt: string;
  updatedAt: string;
  tagId: string | null;
  projectId: string;
};

/** @internal */
export const SaleCreatedEventLink$outboundSchema: z.ZodType<
  SaleCreatedEventLink$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventLink
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean(),
  externalId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  partnerId: z.nullable(z.string()),
  archived: z.boolean(),
  expiresAt: z.string(),
  expiredUrl: z.nullable(z.string()),
  disabledAt: z.string(),
  password: z.nullable(z.string()),
  proxy: z.boolean(),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  rewrite: z.boolean(),
  doIndex: z.boolean(),
  ios: z.nullable(z.string()),
  android: z.nullable(z.string()),
  geo: z.nullable(z.record(z.string())),
  publicStats: z.boolean(),
  tags: z.nullable(z.array(LinkTagSchema$outboundSchema)),
  folderId: z.nullable(z.string()),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utmSource: z.nullable(z.string()),
  utmMedium: z.nullable(z.string()),
  utmCampaign: z.nullable(z.string()),
  utmTerm: z.nullable(z.string()),
  utmContent: z.nullable(z.string()),
  testVariants: z.nullable(
    z.array(z.lazy(() => SaleCreatedEventTestVariants$outboundSchema)),
  ).optional(),
  testStartedAt: z.string(),
  testCompletedAt: z.string(),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  leads: z.number().default(0),
  conversions: z.number().default(0),
  sales: z.number().default(0),
  saleAmount: z.number().default(0),
  lastClicked: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  tagId: z.nullable(z.string()),
  projectId: z.string(),
}).transform((v) => {
  return remap$(v, {
    utmSource: "utm_source",
    utmMedium: "utm_medium",
    utmCampaign: "utm_campaign",
    utmTerm: "utm_term",
    utmContent: "utm_content",
  });
});

export function saleCreatedEventLinkToJSON(
  saleCreatedEventLink: SaleCreatedEventLink,
): string {
  return JSON.stringify(
    SaleCreatedEventLink$outboundSchema.parse(saleCreatedEventLink),
  );
}
export function saleCreatedEventLinkFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventLink' from JSON`,
  );
}

/** @internal */
export const Sale$inboundSchema: z.ZodType<Sale, z.ZodTypeDef, unknown> = z
  .object({
    amount: z.number(),
    currency: z.string(),
    paymentProcessor: z.string(),
    invoiceId: z.nullable(z.string()),
  });
/** @internal */
export type Sale$Outbound = {
  amount: number;
  currency: string;
  paymentProcessor: string;
  invoiceId: string | null;
};

/** @internal */
export const Sale$outboundSchema: z.ZodType<Sale$Outbound, z.ZodTypeDef, Sale> =
  z.object({
    amount: z.number(),
    currency: z.string(),
    paymentProcessor: z.string(),
    invoiceId: z.nullable(z.string()),
  });

export function saleToJSON(sale: Sale): string {
  return JSON.stringify(Sale$outboundSchema.parse(sale));
}
export function saleFromJSON(
  jsonString: string,
): SafeParseResult<Sale, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sale$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sale' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEventPartner$inboundSchema: z.ZodType<
  SaleCreatedEventPartner,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()),
  image: z.nullable(z.string()),
  payoutsEnabledAt: z.nullable(z.string()),
  country: z.nullable(z.string()),
  groupId: z.nullable(z.string()).optional(),
  totalClicks: z.number(),
  totalLeads: z.number(),
  totalConversions: z.number(),
  totalSales: z.number(),
  totalSaleAmount: z.number(),
  totalCommissions: z.number(),
});
/** @internal */
export type SaleCreatedEventPartner$Outbound = {
  id: string;
  name: string;
  email: string | null;
  image: string | null;
  payoutsEnabledAt: string | null;
  country: string | null;
  groupId?: string | null | undefined;
  totalClicks: number;
  totalLeads: number;
  totalConversions: number;
  totalSales: number;
  totalSaleAmount: number;
  totalCommissions: number;
};

/** @internal */
export const SaleCreatedEventPartner$outboundSchema: z.ZodType<
  SaleCreatedEventPartner$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventPartner
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()),
  image: z.nullable(z.string()),
  payoutsEnabledAt: z.nullable(z.string()),
  country: z.nullable(z.string()),
  groupId: z.nullable(z.string()).optional(),
  totalClicks: z.number(),
  totalLeads: z.number(),
  totalConversions: z.number(),
  totalSales: z.number(),
  totalSaleAmount: z.number(),
  totalCommissions: z.number(),
});

export function saleCreatedEventPartnerToJSON(
  saleCreatedEventPartner: SaleCreatedEventPartner,
): string {
  return JSON.stringify(
    SaleCreatedEventPartner$outboundSchema.parse(saleCreatedEventPartner),
  );
}
export function saleCreatedEventPartnerFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventPartner, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventPartner$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventPartner' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEventData$inboundSchema: z.ZodType<
  SaleCreatedEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  eventName: z.string(),
  customer: z.lazy(() => SaleCreatedEventCustomer$inboundSchema),
  click: z.lazy(() => SaleCreatedEventClick$inboundSchema),
  link: z.lazy(() => SaleCreatedEventLink$inboundSchema),
  sale: z.lazy(() => Sale$inboundSchema),
  partner: z.nullable(z.lazy(() => SaleCreatedEventPartner$inboundSchema))
    .optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
});
/** @internal */
export type SaleCreatedEventData$Outbound = {
  eventName: string;
  customer: SaleCreatedEventCustomer$Outbound;
  click: SaleCreatedEventClick$Outbound;
  link: SaleCreatedEventLink$Outbound;
  sale: Sale$Outbound;
  partner?: SaleCreatedEventPartner$Outbound | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const SaleCreatedEventData$outboundSchema: z.ZodType<
  SaleCreatedEventData$Outbound,
  z.ZodTypeDef,
  SaleCreatedEventData
> = z.object({
  eventName: z.string(),
  customer: z.lazy(() => SaleCreatedEventCustomer$outboundSchema),
  click: z.lazy(() => SaleCreatedEventClick$outboundSchema),
  link: z.lazy(() => SaleCreatedEventLink$outboundSchema),
  sale: z.lazy(() => Sale$outboundSchema),
  partner: z.nullable(z.lazy(() => SaleCreatedEventPartner$outboundSchema))
    .optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
});

export function saleCreatedEventDataToJSON(
  saleCreatedEventData: SaleCreatedEventData,
): string {
  return JSON.stringify(
    SaleCreatedEventData$outboundSchema.parse(saleCreatedEventData),
  );
}
export function saleCreatedEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEventData' from JSON`,
  );
}

/** @internal */
export const SaleCreatedEvent$inboundSchema: z.ZodType<
  SaleCreatedEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  event: SaleCreatedEventEvent$inboundSchema,
  createdAt: z.string(),
  data: z.lazy(() => SaleCreatedEventData$inboundSchema),
});
/** @internal */
export type SaleCreatedEvent$Outbound = {
  id: string;
  event: string;
  createdAt: string;
  data: SaleCreatedEventData$Outbound;
};

/** @internal */
export const SaleCreatedEvent$outboundSchema: z.ZodType<
  SaleCreatedEvent$Outbound,
  z.ZodTypeDef,
  SaleCreatedEvent
> = z.object({
  id: z.string(),
  event: SaleCreatedEventEvent$outboundSchema,
  createdAt: z.string(),
  data: z.lazy(() => SaleCreatedEventData$outboundSchema),
});

export function saleCreatedEventToJSON(
  saleCreatedEvent: SaleCreatedEvent,
): string {
  return JSON.stringify(
    SaleCreatedEvent$outboundSchema.parse(saleCreatedEvent),
  );
}
export function saleCreatedEventFromJSON(
  jsonString: string,
): SafeParseResult<SaleCreatedEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleCreatedEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleCreatedEvent' from JSON`,
  );
}
