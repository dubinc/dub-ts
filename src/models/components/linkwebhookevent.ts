/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  TagSchema,
  TagSchema$inboundSchema,
  TagSchema$Outbound,
  TagSchema$outboundSchema,
} from "./tagschema.js";

export const Three = {
  LinkDeleted: "link.deleted",
} as const;
export type Three = ClosedEnum<typeof Three>;

export const Two = {
  LinkUpdated: "link.updated",
} as const;
export type Two = ClosedEnum<typeof Two>;

export const One = {
  LinkCreated: "link.created",
} as const;
export type One = ClosedEnum<typeof One>;

export type LinkWebhookEventEvent = One | Two | Three;

export type LinkWebhookEventTestVariants = {
  url: string;
  percentage: number;
};

export type LinkWebhookEventLink = {
  /**
   * The unique ID of the short link.
   */
  id: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `dub.sh` if the workspace has no domains).
   */
  domain: string;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key: string;
  url: string;
  trackConversion: boolean;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId: string | null;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId: string | null;
  /**
   * The ID of the program the short link is associated with.
   */
  programId: string | null;
  /**
   * The ID of the partner the short link is associated with.
   */
  partnerId: string | null;
  archived: boolean;
  expiresAt: string;
  expiredUrl: string | null;
  /**
   * The password required to access the destination URL of the short link.
   */
  password: string | null;
  proxy: boolean;
  /**
   * The title of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  title: string | null;
  /**
   * The description of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  description: string | null;
  /**
   * The image of the short link. Will be used for Custom Link Previews if `proxy` is true.
   */
  image: string | null;
  /**
   * The custom link preview video (og:video). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  video: string | null;
  rewrite: boolean;
  doIndex: boolean;
  /**
   * The iOS destination URL for the short link for iOS device targeting.
   */
  ios: string | null;
  /**
   * The Android destination URL for the short link for Android device targeting.
   */
  android: string | null;
  /**
   * Geo targeting information for the short link in JSON format `{[COUNTRY]: https://example.com }`. See https://d.to/geo for more information.
   */
  geo: { [k: string]: string } | null;
  publicStats: boolean;
  /**
   * The tags assigned to the short link.
   */
  tags: Array<TagSchema> | null;
  /**
   * The unique ID of the folder assigned to the short link.
   */
  folderId: string | null;
  /**
   * The IDs of the webhooks that the short link is associated with.
   */
  webhookIds: Array<string>;
  /**
   * The comments for the short link.
   */
  comments: string | null;
  /**
   * The full URL of the short link, including the https protocol (e.g. `https://dub.sh/try`).
   */
  shortLink: string;
  /**
   * The full URL of the QR code for the short link (e.g. `https://api.dub.co/qr?url=https://dub.sh/try`).
   */
  qrCode: string;
  /**
   * The UTM source of the short link.
   */
  utmSource: string | null;
  /**
   * The UTM medium of the short link.
   */
  utmMedium: string | null;
  /**
   * The UTM campaign of the short link.
   */
  utmCampaign: string | null;
  /**
   * The UTM term of the short link.
   */
  utmTerm: string | null;
  /**
   * The UTM content of the short link.
   */
  utmContent: string | null;
  /**
   * An array of A/B test URLs and the percentage of traffic to send to each URL.
   */
  testVariants?: Array<LinkWebhookEventTestVariants> | null | undefined;
  testStartedAt: string | null;
  testCompletedAt: string | null;
  userId: string | null;
  /**
   * The workspace ID of the short link.
   */
  workspaceId: string;
  /**
   * The number of clicks on the short link.
   */
  clicks?: number | undefined;
  /**
   * The number of leads the short link has generated.
   */
  leads?: number | undefined;
  /**
   * The number of leads that converted to paying customers.
   */
  conversions?: number | undefined;
  /**
   * The total number of sales (includes recurring sales) generated by the short link.
   */
  sales?: number | undefined;
  /**
   * The total dollar value of sales (in cents) generated by the short link.
   */
  saleAmount?: number | undefined;
  lastClicked: string;
  createdAt: string;
  updatedAt: string;
  /**
   * Deprecated: Use `tags` instead. The unique ID of the tag assigned to the short link.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  tagId: string | null;
  /**
   * Deprecated: Use `workspaceId` instead. The project ID of the short link.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  projectId: string;
};

/**
 * Triggered when a link is created, updated, or deleted.
 */
export type LinkWebhookEvent = {
  id: string;
  event: One | Two | Three;
  createdAt: string;
  data: LinkWebhookEventLink;
};

/** @internal */
export const Three$inboundSchema: z.ZodNativeEnum<typeof Three> = z.nativeEnum(
  Three,
);

/** @internal */
export const Three$outboundSchema: z.ZodNativeEnum<typeof Three> =
  Three$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Three$ {
  /** @deprecated use `Three$inboundSchema` instead. */
  export const inboundSchema = Three$inboundSchema;
  /** @deprecated use `Three$outboundSchema` instead. */
  export const outboundSchema = Three$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodNativeEnum<typeof Two> = z.nativeEnum(Two);

/** @internal */
export const Two$outboundSchema: z.ZodNativeEnum<typeof Two> =
  Two$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
}

/** @internal */
export const One$inboundSchema: z.ZodNativeEnum<typeof One> = z.nativeEnum(One);

/** @internal */
export const One$outboundSchema: z.ZodNativeEnum<typeof One> =
  One$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
}

/** @internal */
export const LinkWebhookEventEvent$inboundSchema: z.ZodType<
  LinkWebhookEventEvent,
  z.ZodTypeDef,
  unknown
> = z.union([One$inboundSchema, Two$inboundSchema, Three$inboundSchema]);

/** @internal */
export type LinkWebhookEventEvent$Outbound = string | string | string;

/** @internal */
export const LinkWebhookEventEvent$outboundSchema: z.ZodType<
  LinkWebhookEventEvent$Outbound,
  z.ZodTypeDef,
  LinkWebhookEventEvent
> = z.union([One$outboundSchema, Two$outboundSchema, Three$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkWebhookEventEvent$ {
  /** @deprecated use `LinkWebhookEventEvent$inboundSchema` instead. */
  export const inboundSchema = LinkWebhookEventEvent$inboundSchema;
  /** @deprecated use `LinkWebhookEventEvent$outboundSchema` instead. */
  export const outboundSchema = LinkWebhookEventEvent$outboundSchema;
  /** @deprecated use `LinkWebhookEventEvent$Outbound` instead. */
  export type Outbound = LinkWebhookEventEvent$Outbound;
}

export function linkWebhookEventEventToJSON(
  linkWebhookEventEvent: LinkWebhookEventEvent,
): string {
  return JSON.stringify(
    LinkWebhookEventEvent$outboundSchema.parse(linkWebhookEventEvent),
  );
}

export function linkWebhookEventEventFromJSON(
  jsonString: string,
): SafeParseResult<LinkWebhookEventEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkWebhookEventEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkWebhookEventEvent' from JSON`,
  );
}

/** @internal */
export const LinkWebhookEventTestVariants$inboundSchema: z.ZodType<
  LinkWebhookEventTestVariants,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/** @internal */
export type LinkWebhookEventTestVariants$Outbound = {
  url: string;
  percentage: number;
};

/** @internal */
export const LinkWebhookEventTestVariants$outboundSchema: z.ZodType<
  LinkWebhookEventTestVariants$Outbound,
  z.ZodTypeDef,
  LinkWebhookEventTestVariants
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkWebhookEventTestVariants$ {
  /** @deprecated use `LinkWebhookEventTestVariants$inboundSchema` instead. */
  export const inboundSchema = LinkWebhookEventTestVariants$inboundSchema;
  /** @deprecated use `LinkWebhookEventTestVariants$outboundSchema` instead. */
  export const outboundSchema = LinkWebhookEventTestVariants$outboundSchema;
  /** @deprecated use `LinkWebhookEventTestVariants$Outbound` instead. */
  export type Outbound = LinkWebhookEventTestVariants$Outbound;
}

export function linkWebhookEventTestVariantsToJSON(
  linkWebhookEventTestVariants: LinkWebhookEventTestVariants,
): string {
  return JSON.stringify(
    LinkWebhookEventTestVariants$outboundSchema.parse(
      linkWebhookEventTestVariants,
    ),
  );
}

export function linkWebhookEventTestVariantsFromJSON(
  jsonString: string,
): SafeParseResult<LinkWebhookEventTestVariants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkWebhookEventTestVariants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkWebhookEventTestVariants' from JSON`,
  );
}

/** @internal */
export const LinkWebhookEventLink$inboundSchema: z.ZodType<
  LinkWebhookEventLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean(),
  externalId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  partnerId: z.nullable(z.string()),
  archived: z.boolean(),
  expiresAt: z.string(),
  expiredUrl: z.nullable(z.string()),
  password: z.nullable(z.string()),
  proxy: z.boolean(),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  rewrite: z.boolean(),
  doIndex: z.boolean(),
  ios: z.nullable(z.string()),
  android: z.nullable(z.string()),
  geo: z.nullable(z.record(z.string())),
  publicStats: z.boolean(),
  tags: z.nullable(z.array(TagSchema$inboundSchema)),
  folderId: z.nullable(z.string()),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utm_source: z.nullable(z.string()),
  utm_medium: z.nullable(z.string()),
  utm_campaign: z.nullable(z.string()),
  utm_term: z.nullable(z.string()),
  utm_content: z.nullable(z.string()),
  testVariants: z.nullable(
    z.array(z.lazy(() => LinkWebhookEventTestVariants$inboundSchema)),
  ).optional(),
  testStartedAt: z.nullable(z.string()),
  testCompletedAt: z.nullable(z.string()),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  leads: z.number().default(0),
  conversions: z.number().default(0),
  sales: z.number().default(0),
  saleAmount: z.number().default(0),
  lastClicked: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  tagId: z.nullable(z.string()),
  projectId: z.string(),
}).transform((v) => {
  return remap$(v, {
    "utm_source": "utmSource",
    "utm_medium": "utmMedium",
    "utm_campaign": "utmCampaign",
    "utm_term": "utmTerm",
    "utm_content": "utmContent",
  });
});

/** @internal */
export type LinkWebhookEventLink$Outbound = {
  id: string;
  domain: string;
  key: string;
  url: string;
  trackConversion: boolean;
  externalId: string | null;
  tenantId: string | null;
  programId: string | null;
  partnerId: string | null;
  archived: boolean;
  expiresAt: string;
  expiredUrl: string | null;
  password: string | null;
  proxy: boolean;
  title: string | null;
  description: string | null;
  image: string | null;
  video: string | null;
  rewrite: boolean;
  doIndex: boolean;
  ios: string | null;
  android: string | null;
  geo: { [k: string]: string } | null;
  publicStats: boolean;
  tags: Array<TagSchema$Outbound> | null;
  folderId: string | null;
  webhookIds: Array<string>;
  comments: string | null;
  shortLink: string;
  qrCode: string;
  utm_source: string | null;
  utm_medium: string | null;
  utm_campaign: string | null;
  utm_term: string | null;
  utm_content: string | null;
  testVariants?:
    | Array<LinkWebhookEventTestVariants$Outbound>
    | null
    | undefined;
  testStartedAt: string | null;
  testCompletedAt: string | null;
  userId: string | null;
  workspaceId: string;
  clicks: number;
  leads: number;
  conversions: number;
  sales: number;
  saleAmount: number;
  lastClicked: string;
  createdAt: string;
  updatedAt: string;
  tagId: string | null;
  projectId: string;
};

/** @internal */
export const LinkWebhookEventLink$outboundSchema: z.ZodType<
  LinkWebhookEventLink$Outbound,
  z.ZodTypeDef,
  LinkWebhookEventLink
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean(),
  externalId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  partnerId: z.nullable(z.string()),
  archived: z.boolean(),
  expiresAt: z.string(),
  expiredUrl: z.nullable(z.string()),
  password: z.nullable(z.string()),
  proxy: z.boolean(),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  rewrite: z.boolean(),
  doIndex: z.boolean(),
  ios: z.nullable(z.string()),
  android: z.nullable(z.string()),
  geo: z.nullable(z.record(z.string())),
  publicStats: z.boolean(),
  tags: z.nullable(z.array(TagSchema$outboundSchema)),
  folderId: z.nullable(z.string()),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utmSource: z.nullable(z.string()),
  utmMedium: z.nullable(z.string()),
  utmCampaign: z.nullable(z.string()),
  utmTerm: z.nullable(z.string()),
  utmContent: z.nullable(z.string()),
  testVariants: z.nullable(
    z.array(z.lazy(() => LinkWebhookEventTestVariants$outboundSchema)),
  ).optional(),
  testStartedAt: z.nullable(z.string()),
  testCompletedAt: z.nullable(z.string()),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  leads: z.number().default(0),
  conversions: z.number().default(0),
  sales: z.number().default(0),
  saleAmount: z.number().default(0),
  lastClicked: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  tagId: z.nullable(z.string()),
  projectId: z.string(),
}).transform((v) => {
  return remap$(v, {
    utmSource: "utm_source",
    utmMedium: "utm_medium",
    utmCampaign: "utm_campaign",
    utmTerm: "utm_term",
    utmContent: "utm_content",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkWebhookEventLink$ {
  /** @deprecated use `LinkWebhookEventLink$inboundSchema` instead. */
  export const inboundSchema = LinkWebhookEventLink$inboundSchema;
  /** @deprecated use `LinkWebhookEventLink$outboundSchema` instead. */
  export const outboundSchema = LinkWebhookEventLink$outboundSchema;
  /** @deprecated use `LinkWebhookEventLink$Outbound` instead. */
  export type Outbound = LinkWebhookEventLink$Outbound;
}

export function linkWebhookEventLinkToJSON(
  linkWebhookEventLink: LinkWebhookEventLink,
): string {
  return JSON.stringify(
    LinkWebhookEventLink$outboundSchema.parse(linkWebhookEventLink),
  );
}

export function linkWebhookEventLinkFromJSON(
  jsonString: string,
): SafeParseResult<LinkWebhookEventLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkWebhookEventLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkWebhookEventLink' from JSON`,
  );
}

/** @internal */
export const LinkWebhookEvent$inboundSchema: z.ZodType<
  LinkWebhookEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  event: z.union([One$inboundSchema, Two$inboundSchema, Three$inboundSchema]),
  createdAt: z.string(),
  data: z.lazy(() => LinkWebhookEventLink$inboundSchema),
});

/** @internal */
export type LinkWebhookEvent$Outbound = {
  id: string;
  event: string | string | string;
  createdAt: string;
  data: LinkWebhookEventLink$Outbound;
};

/** @internal */
export const LinkWebhookEvent$outboundSchema: z.ZodType<
  LinkWebhookEvent$Outbound,
  z.ZodTypeDef,
  LinkWebhookEvent
> = z.object({
  id: z.string(),
  event: z.union([
    One$outboundSchema,
    Two$outboundSchema,
    Three$outboundSchema,
  ]),
  createdAt: z.string(),
  data: z.lazy(() => LinkWebhookEventLink$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LinkWebhookEvent$ {
  /** @deprecated use `LinkWebhookEvent$inboundSchema` instead. */
  export const inboundSchema = LinkWebhookEvent$inboundSchema;
  /** @deprecated use `LinkWebhookEvent$outboundSchema` instead. */
  export const outboundSchema = LinkWebhookEvent$outboundSchema;
  /** @deprecated use `LinkWebhookEvent$Outbound` instead. */
  export type Outbound = LinkWebhookEvent$Outbound;
}

export function linkWebhookEventToJSON(
  linkWebhookEvent: LinkWebhookEvent,
): string {
  return JSON.stringify(
    LinkWebhookEvent$outboundSchema.parse(linkWebhookEvent),
  );
}

export function linkWebhookEventFromJSON(
  jsonString: string,
): SafeParseResult<LinkWebhookEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkWebhookEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkWebhookEvent' from JSON`,
  );
}
