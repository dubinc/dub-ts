/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
 */
export const Mode = {
  Async: "async",
  Wait: "wait",
  Deferred: "deferred",
} as const;
/**
 * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
 */
export type Mode = ClosedEnum<typeof Mode>;

export type TrackLeadRequestBody = {
  /**
   * The unique ID of the click that the lead conversion event is attributed to. You can read this value from `dub_id` cookie. [For deferred lead tracking]: If an empty string is provided, Dub will try to find an existing customer with the provided `customerExternalId` and use the `clickId` from the customer if found.
   */
  clickId: string;
  /**
   * The name of the lead event to track. Can also be used as a unique identifier to associate a given lead event for a customer for a subsequent sale event (via the `leadEventName` prop in `/track/sale`).
   */
  eventName: string;
  /**
   * The unique ID of the customer in your system. Will be used to identify and attribute all future events to this customer.
   */
  customerExternalId: string;
  /**
   * The name of the customer. If not passed, a random name will be generated (e.g. “Big Red Caribou”).
   */
  customerName?: string | null | undefined;
  /**
   * The email address of the customer.
   */
  customerEmail?: string | null | undefined;
  /**
   * The avatar URL of the customer.
   */
  customerAvatar?: string | null | undefined;
  /**
   * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
   */
  mode?: Mode | undefined;
  /**
   * The numerical value associated with this lead event (e.g., number of provisioned seats in a free trial). If defined as N, the lead event will be tracked N times.
   */
  eventQuantity?: number | null | undefined;
  /**
   * Additional metadata to be stored with the lead event. Max 10,000 characters.
   */
  metadata?: { [k: string]: any } | null | undefined;
};

export type Click = {
  id: string;
};

export type TrackLeadLink = {
  /**
   * The unique ID of the short link.
   */
  id: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `dub.sh` if the workspace has no domains).
   */
  domain: string;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key: string;
  /**
   * The full URL of the short link, including the https protocol (e.g. `https://dub.sh/try`).
   */
  shortLink: string;
  /**
   * The destination URL of the short link.
   */
  url: string;
  /**
   * The ID of the partner the short link is associated with.
   */
  partnerId: string | null;
  /**
   * The ID of the program the short link is associated with.
   */
  programId: string | null;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId: string | null;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId: string | null;
};

export type Customer = {
  name: string | null;
  email: string | null;
  avatar: string | null;
  externalId: string | null;
};

/**
 * A lead was tracked.
 */
export type TrackLeadResponseBody = {
  click: Click;
  link: TrackLeadLink | null;
  customer: Customer;
};

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export type TrackLeadRequestBody$Outbound = {
  clickId: string;
  eventName: string;
  customerExternalId: string;
  customerName: string | null;
  customerEmail: string | null;
  customerAvatar: string | null;
  mode: string;
  eventQuantity?: number | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const TrackLeadRequestBody$outboundSchema: z.ZodType<
  TrackLeadRequestBody$Outbound,
  z.ZodTypeDef,
  TrackLeadRequestBody
> = z.object({
  clickId: z.string(),
  eventName: z.string(),
  customerExternalId: z.string(),
  customerName: z.nullable(z.string()).default(null),
  customerEmail: z.nullable(z.string()).default(null),
  customerAvatar: z.nullable(z.string()).default(null),
  mode: Mode$outboundSchema.default("async"),
  eventQuantity: z.nullable(z.number()).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
});

export function trackLeadRequestBodyToJSON(
  trackLeadRequestBody: TrackLeadRequestBody,
): string {
  return JSON.stringify(
    TrackLeadRequestBody$outboundSchema.parse(trackLeadRequestBody),
  );
}

/** @internal */
export const Click$inboundSchema: z.ZodType<Click, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });

export function clickFromJSON(
  jsonString: string,
): SafeParseResult<Click, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Click$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Click' from JSON`,
  );
}

/** @internal */
export const TrackLeadLink$inboundSchema: z.ZodType<
  TrackLeadLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  shortLink: z.string(),
  url: z.string(),
  partnerId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

export function trackLeadLinkFromJSON(
  jsonString: string,
): SafeParseResult<TrackLeadLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackLeadLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackLeadLink' from JSON`,
  );
}

/** @internal */
export const Customer$inboundSchema: z.ZodType<
  Customer,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.nullable(z.string()),
  email: z.nullable(z.string()),
  avatar: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}

/** @internal */
export const TrackLeadResponseBody$inboundSchema: z.ZodType<
  TrackLeadResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  click: z.lazy(() => Click$inboundSchema),
  link: z.nullable(z.lazy(() => TrackLeadLink$inboundSchema)),
  customer: z.lazy(() => Customer$inboundSchema),
});

export function trackLeadResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<TrackLeadResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackLeadResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackLeadResponseBody' from JSON`,
  );
}
