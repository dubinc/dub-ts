/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
 */
export const Mode = {
  Async: "async",
  Wait: "wait",
  Deferred: "deferred",
} as const;
/**
 * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
 */
export type Mode = ClosedEnum<typeof Mode>;

export type TrackLeadRequestBody = {
  /**
   * The unique ID of the click that the lead conversion event is attributed to. You can read this value from `dub_id` cookie. [For deferred lead tracking]: If an empty string is provided, Dub will try to find an existing customer with the provided `customerExternalId` and use the `clickId` from the customer if found.
   */
  clickId: string;
  /**
   * The name of the lead event to track. Can also be used as a unique identifier to associate a given lead event for a customer for a subsequent sale event (via the `leadEventName` prop in `/track/sale`).
   */
  eventName: string;
  /**
   * The unique ID of the customer in your system. Will be used to identify and attribute all future events to this customer.
   */
  customerExternalId: string;
  /**
   * The name of the customer. If not passed, a random name will be generated (e.g. “Big Red Caribou”).
   */
  customerName?: string | null | undefined;
  /**
   * The email address of the customer.
   */
  customerEmail?: string | null | undefined;
  /**
   * The avatar URL of the customer.
   */
  customerAvatar?: string | null | undefined;
  /**
   * The mode to use for tracking the lead event. `async` will not block the request; `wait` will block the request until the lead event is fully recorded in Dub; `deferred` will defer the lead event creation to a subsequent request.
   */
  mode?: Mode | undefined;
  /**
   * The numerical value associated with this lead event (e.g., number of provisioned seats in a free trial). If defined as N, the lead event will be tracked N times.
   */
  eventQuantity?: number | null | undefined;
  /**
   * Additional metadata to be stored with the lead event. Max 10,000 characters.
   */
  metadata?: { [k: string]: any } | null | undefined;
};

export type Click = {
  id: string;
};

export type TrackLeadLink = {
  /**
   * The unique ID of the short link.
   */
  id: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `dub.sh` if the workspace has no domains).
   */
  domain: string;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key: string;
  /**
   * The full URL of the short link, including the https protocol (e.g. `https://dub.sh/try`).
   */
  shortLink: string;
  /**
   * The destination URL of the short link.
   */
  url: string;
  /**
   * The ID of the partner the short link is associated with.
   */
  partnerId: string | null;
  /**
   * The ID of the program the short link is associated with.
   */
  programId: string | null;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId: string | null;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId: string | null;
};

export type Customer = {
  name: string | null;
  email: string | null;
  avatar: string | null;
  externalId: string | null;
};

/**
 * A lead was tracked.
 */
export type TrackLeadResponseBody = {
  click: Click;
  link: TrackLeadLink | null;
  customer: Customer;
};

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode$ {
  /** @deprecated use `Mode$inboundSchema` instead. */
  export const inboundSchema = Mode$inboundSchema;
  /** @deprecated use `Mode$outboundSchema` instead. */
  export const outboundSchema = Mode$outboundSchema;
}

/** @internal */
export const TrackLeadRequestBody$inboundSchema: z.ZodType<
  TrackLeadRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  clickId: z.string(),
  eventName: z.string(),
  customerExternalId: z.string(),
  customerName: z.nullable(z.string()).default(null),
  customerEmail: z.nullable(z.string()).default(null),
  customerAvatar: z.nullable(z.string()).default(null),
  mode: Mode$inboundSchema.default("async"),
  eventQuantity: z.nullable(z.number()).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
});

/** @internal */
export type TrackLeadRequestBody$Outbound = {
  clickId: string;
  eventName: string;
  customerExternalId: string;
  customerName: string | null;
  customerEmail: string | null;
  customerAvatar: string | null;
  mode: string;
  eventQuantity?: number | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const TrackLeadRequestBody$outboundSchema: z.ZodType<
  TrackLeadRequestBody$Outbound,
  z.ZodTypeDef,
  TrackLeadRequestBody
> = z.object({
  clickId: z.string(),
  eventName: z.string(),
  customerExternalId: z.string(),
  customerName: z.nullable(z.string()).default(null),
  customerEmail: z.nullable(z.string()).default(null),
  customerAvatar: z.nullable(z.string()).default(null),
  mode: Mode$outboundSchema.default("async"),
  eventQuantity: z.nullable(z.number()).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TrackLeadRequestBody$ {
  /** @deprecated use `TrackLeadRequestBody$inboundSchema` instead. */
  export const inboundSchema = TrackLeadRequestBody$inboundSchema;
  /** @deprecated use `TrackLeadRequestBody$outboundSchema` instead. */
  export const outboundSchema = TrackLeadRequestBody$outboundSchema;
  /** @deprecated use `TrackLeadRequestBody$Outbound` instead. */
  export type Outbound = TrackLeadRequestBody$Outbound;
}

export function trackLeadRequestBodyToJSON(
  trackLeadRequestBody: TrackLeadRequestBody,
): string {
  return JSON.stringify(
    TrackLeadRequestBody$outboundSchema.parse(trackLeadRequestBody),
  );
}

export function trackLeadRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<TrackLeadRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackLeadRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackLeadRequestBody' from JSON`,
  );
}

/** @internal */
export const Click$inboundSchema: z.ZodType<Click, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });

/** @internal */
export type Click$Outbound = {
  id: string;
};

/** @internal */
export const Click$outboundSchema: z.ZodType<
  Click$Outbound,
  z.ZodTypeDef,
  Click
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Click$ {
  /** @deprecated use `Click$inboundSchema` instead. */
  export const inboundSchema = Click$inboundSchema;
  /** @deprecated use `Click$outboundSchema` instead. */
  export const outboundSchema = Click$outboundSchema;
  /** @deprecated use `Click$Outbound` instead. */
  export type Outbound = Click$Outbound;
}

export function clickToJSON(click: Click): string {
  return JSON.stringify(Click$outboundSchema.parse(click));
}

export function clickFromJSON(
  jsonString: string,
): SafeParseResult<Click, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Click$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Click' from JSON`,
  );
}

/** @internal */
export const TrackLeadLink$inboundSchema: z.ZodType<
  TrackLeadLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  shortLink: z.string(),
  url: z.string(),
  partnerId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

/** @internal */
export type TrackLeadLink$Outbound = {
  id: string;
  domain: string;
  key: string;
  shortLink: string;
  url: string;
  partnerId: string | null;
  programId: string | null;
  tenantId: string | null;
  externalId: string | null;
};

/** @internal */
export const TrackLeadLink$outboundSchema: z.ZodType<
  TrackLeadLink$Outbound,
  z.ZodTypeDef,
  TrackLeadLink
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  shortLink: z.string(),
  url: z.string(),
  partnerId: z.nullable(z.string()),
  programId: z.nullable(z.string()),
  tenantId: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TrackLeadLink$ {
  /** @deprecated use `TrackLeadLink$inboundSchema` instead. */
  export const inboundSchema = TrackLeadLink$inboundSchema;
  /** @deprecated use `TrackLeadLink$outboundSchema` instead. */
  export const outboundSchema = TrackLeadLink$outboundSchema;
  /** @deprecated use `TrackLeadLink$Outbound` instead. */
  export type Outbound = TrackLeadLink$Outbound;
}

export function trackLeadLinkToJSON(trackLeadLink: TrackLeadLink): string {
  return JSON.stringify(TrackLeadLink$outboundSchema.parse(trackLeadLink));
}

export function trackLeadLinkFromJSON(
  jsonString: string,
): SafeParseResult<TrackLeadLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackLeadLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackLeadLink' from JSON`,
  );
}

/** @internal */
export const Customer$inboundSchema: z.ZodType<
  Customer,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.nullable(z.string()),
  email: z.nullable(z.string()),
  avatar: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

/** @internal */
export type Customer$Outbound = {
  name: string | null;
  email: string | null;
  avatar: string | null;
  externalId: string | null;
};

/** @internal */
export const Customer$outboundSchema: z.ZodType<
  Customer$Outbound,
  z.ZodTypeDef,
  Customer
> = z.object({
  name: z.nullable(z.string()),
  email: z.nullable(z.string()),
  avatar: z.nullable(z.string()),
  externalId: z.nullable(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Customer$ {
  /** @deprecated use `Customer$inboundSchema` instead. */
  export const inboundSchema = Customer$inboundSchema;
  /** @deprecated use `Customer$outboundSchema` instead. */
  export const outboundSchema = Customer$outboundSchema;
  /** @deprecated use `Customer$Outbound` instead. */
  export type Outbound = Customer$Outbound;
}

export function customerToJSON(customer: Customer): string {
  return JSON.stringify(Customer$outboundSchema.parse(customer));
}

export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}

/** @internal */
export const TrackLeadResponseBody$inboundSchema: z.ZodType<
  TrackLeadResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  click: z.lazy(() => Click$inboundSchema),
  link: z.nullable(z.lazy(() => TrackLeadLink$inboundSchema)),
  customer: z.lazy(() => Customer$inboundSchema),
});

/** @internal */
export type TrackLeadResponseBody$Outbound = {
  click: Click$Outbound;
  link: TrackLeadLink$Outbound | null;
  customer: Customer$Outbound;
};

/** @internal */
export const TrackLeadResponseBody$outboundSchema: z.ZodType<
  TrackLeadResponseBody$Outbound,
  z.ZodTypeDef,
  TrackLeadResponseBody
> = z.object({
  click: z.lazy(() => Click$outboundSchema),
  link: z.nullable(z.lazy(() => TrackLeadLink$outboundSchema)),
  customer: z.lazy(() => Customer$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TrackLeadResponseBody$ {
  /** @deprecated use `TrackLeadResponseBody$inboundSchema` instead. */
  export const inboundSchema = TrackLeadResponseBody$inboundSchema;
  /** @deprecated use `TrackLeadResponseBody$outboundSchema` instead. */
  export const outboundSchema = TrackLeadResponseBody$outboundSchema;
  /** @deprecated use `TrackLeadResponseBody$Outbound` instead. */
  export type Outbound = TrackLeadResponseBody$Outbound;
}

export function trackLeadResponseBodyToJSON(
  trackLeadResponseBody: TrackLeadResponseBody,
): string {
  return JSON.stringify(
    TrackLeadResponseBody$outboundSchema.parse(trackLeadResponseBody),
  );
}

export function trackLeadResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<TrackLeadResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrackLeadResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrackLeadResponseBody' from JSON`,
  );
}
