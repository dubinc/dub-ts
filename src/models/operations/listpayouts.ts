/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Filter the list of payouts by their corresponding status.
 */
export const ListPayoutsQueryParamStatus = {
  Pending: "pending",
  Processing: "processing",
  Processed: "processed",
  Sent: "sent",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
} as const;
/**
 * Filter the list of payouts by their corresponding status.
 */
export type ListPayoutsQueryParamStatus = ClosedEnum<
  typeof ListPayoutsQueryParamStatus
>;

/**
 * The field to sort the list of payouts by.
 */
export const ListPayoutsQueryParamSortBy = {
  Amount: "amount",
  InitiatedAt: "initiatedAt",
  PaidAt: "paidAt",
} as const;
/**
 * The field to sort the list of payouts by.
 */
export type ListPayoutsQueryParamSortBy = ClosedEnum<
  typeof ListPayoutsQueryParamSortBy
>;

/**
 * The sort order for the list of payouts.
 */
export const ListPayoutsQueryParamSortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * The sort order for the list of payouts.
 */
export type ListPayoutsQueryParamSortOrder = ClosedEnum<
  typeof ListPayoutsQueryParamSortOrder
>;

export type ListPayoutsRequest = {
  /**
   * Filter the list of payouts by their corresponding status.
   */
  status?: ListPayoutsQueryParamStatus | undefined;
  /**
   * Filter the list of payouts by the associated partner. When specified, takes precedence over `tenantId`.
   */
  partnerId?: string | undefined;
  /**
   * Filter the list of payouts by the associated partner's `tenantId` (their unique ID within your database).
   */
  tenantId?: string | undefined;
  /**
   * Filter the list of payouts by invoice ID (the unique ID of the invoice you receive for each batch payout you process on Dub). Pending payouts will not have an invoice ID.
   */
  invoiceId?: string | undefined;
  /**
   * The field to sort the list of payouts by.
   */
  sortBy?: ListPayoutsQueryParamSortBy | undefined;
  /**
   * The sort order for the list of payouts.
   */
  sortOrder?: ListPayoutsQueryParamSortOrder | undefined;
  /**
   * The page number for pagination.
   */
  page?: number | undefined;
  /**
   * The number of items per page.
   */
  pageSize?: number | undefined;
};

export const ListPayoutsStatus = {
  Pending: "pending",
  Processing: "processing",
  Processed: "processed",
  Sent: "sent",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
} as const;
export type ListPayoutsStatus = ClosedEnum<typeof ListPayoutsStatus>;

export const ListPayoutsMode = {
  Internal: "internal",
  External: "external",
} as const;
export type ListPayoutsMode = ClosedEnum<typeof ListPayoutsMode>;

export type ListPayoutsPartner = {
  /**
   * The partner's unique ID on Dub.
   */
  id: string;
  /**
   * The partner's full legal name.
   */
  name: string;
  /**
   * The partner's email address. Should be a unique value across Dub.
   */
  email: string | null;
  /**
   * The partner's avatar image.
   */
  image: string | null;
  /**
   * The date when the partner enabled payouts.
   */
  payoutsEnabledAt: string | null;
  /**
   * The partner's country (required for tax purposes).
   */
  country: string | null;
  /**
   * The partner's group ID on Dub.
   */
  groupId?: string | null | undefined;
  /**
   * The partner's unique ID within your database. Can be useful for associating the partner with a user in your database and retrieving/update their data in the future.
   */
  tenantId: string | null;
};

export type User = {
  id: string;
  name: string | null;
  email: string | null;
  image: string | null;
};

export type ListPayoutsResponseBody = {
  id: string;
  invoiceId: string | null;
  amount: number;
  currency: string;
  status: ListPayoutsStatus;
  description?: string | null | undefined;
  periodStart: string | null;
  periodEnd: string | null;
  createdAt: string;
  initiatedAt: string | null;
  paidAt: string | null;
  failureReason?: string | null | undefined;
  mode: ListPayoutsMode | null;
  partner: ListPayoutsPartner;
  user?: User | null | undefined;
};

/** @internal */
export const ListPayoutsQueryParamStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListPayoutsQueryParamStatus
> = z.nativeEnum(ListPayoutsQueryParamStatus);

/** @internal */
export const ListPayoutsQueryParamSortBy$outboundSchema: z.ZodNativeEnum<
  typeof ListPayoutsQueryParamSortBy
> = z.nativeEnum(ListPayoutsQueryParamSortBy);

/** @internal */
export const ListPayoutsQueryParamSortOrder$outboundSchema: z.ZodNativeEnum<
  typeof ListPayoutsQueryParamSortOrder
> = z.nativeEnum(ListPayoutsQueryParamSortOrder);

/** @internal */
export type ListPayoutsRequest$Outbound = {
  status?: string | undefined;
  partnerId?: string | undefined;
  tenantId?: string | undefined;
  invoiceId?: string | undefined;
  sortBy: string;
  sortOrder: string;
  page: number;
  pageSize: number;
};

/** @internal */
export const ListPayoutsRequest$outboundSchema: z.ZodType<
  ListPayoutsRequest$Outbound,
  z.ZodTypeDef,
  ListPayoutsRequest
> = z.object({
  status: ListPayoutsQueryParamStatus$outboundSchema.optional(),
  partnerId: z.string().optional(),
  tenantId: z.string().optional(),
  invoiceId: z.string().optional(),
  sortBy: ListPayoutsQueryParamSortBy$outboundSchema.default("amount"),
  sortOrder: ListPayoutsQueryParamSortOrder$outboundSchema.default("desc"),
  page: z.number().default(1),
  pageSize: z.number().default(100),
});

export function listPayoutsRequestToJSON(
  listPayoutsRequest: ListPayoutsRequest,
): string {
  return JSON.stringify(
    ListPayoutsRequest$outboundSchema.parse(listPayoutsRequest),
  );
}

/** @internal */
export const ListPayoutsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListPayoutsStatus
> = z.nativeEnum(ListPayoutsStatus);

/** @internal */
export const ListPayoutsMode$inboundSchema: z.ZodNativeEnum<
  typeof ListPayoutsMode
> = z.nativeEnum(ListPayoutsMode);

/** @internal */
export const ListPayoutsPartner$inboundSchema: z.ZodType<
  ListPayoutsPartner,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()),
  image: z.nullable(z.string()),
  payoutsEnabledAt: z.nullable(z.string()),
  country: z.nullable(z.string()),
  groupId: z.nullable(z.string()).optional(),
  tenantId: z.nullable(z.string()),
});

export function listPayoutsPartnerFromJSON(
  jsonString: string,
): SafeParseResult<ListPayoutsPartner, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPayoutsPartner$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPayoutsPartner' from JSON`,
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    name: z.nullable(z.string()),
    email: z.nullable(z.string()),
    image: z.nullable(z.string()),
  });

export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}

/** @internal */
export const ListPayoutsResponseBody$inboundSchema: z.ZodType<
  ListPayoutsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  invoiceId: z.nullable(z.string()),
  amount: z.number(),
  currency: z.string(),
  status: ListPayoutsStatus$inboundSchema,
  description: z.nullable(z.string()).optional(),
  periodStart: z.nullable(z.string()),
  periodEnd: z.nullable(z.string()),
  createdAt: z.string(),
  initiatedAt: z.nullable(z.string()),
  paidAt: z.nullable(z.string()),
  failureReason: z.nullable(z.string()).optional(),
  mode: z.nullable(ListPayoutsMode$inboundSchema),
  partner: z.lazy(() => ListPayoutsPartner$inboundSchema),
  user: z.nullable(z.lazy(() => User$inboundSchema)).optional(),
});

export function listPayoutsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListPayoutsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPayoutsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPayoutsResponseBody' from JSON`,
  );
}
