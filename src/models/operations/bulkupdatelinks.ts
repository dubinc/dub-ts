/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The unique IDs of the tags assigned to the short link.
 */
export type BulkUpdateLinksTagIds = string | Array<string>;

/**
 * The unique name of the tags assigned to the short link (case insensitive).
 */
export type BulkUpdateLinksTagNames = string | Array<string>;

export type BulkUpdateLinksTestVariants = {
  url: string;
  percentage: number;
};

export type Data = {
  /**
   * The destination URL of the short link.
   */
  url?: string | undefined;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId?: string | null | undefined;
  /**
   * The ID of the program the short link is associated with.
   */
  programId?: string | null | undefined;
  /**
   * The ID of the partner the short link is associated with.
   */
  partnerId?: string | null | undefined;
  /**
   * Whether to track conversions for the short link. Defaults to `false` if not provided.
   */
  trackConversion?: boolean | undefined;
  /**
   * Whether the short link is archived. Defaults to `false` if not provided.
   */
  archived?: boolean | undefined;
  /**
   * Deprecated: Use `dashboard` instead. Whether the short link's stats are publicly accessible. Defaults to `false` if not provided.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  publicStats?: boolean | undefined;
  /**
   * The unique ID of the tag assigned to the short link. This field is deprecated â€“ use `tagIds` instead.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  tagId?: string | null | undefined;
  /**
   * The unique IDs of the tags assigned to the short link.
   */
  tagIds?: string | Array<string> | undefined;
  /**
   * The unique name of the tags assigned to the short link (case insensitive).
   */
  tagNames?: string | Array<string> | undefined;
  /**
   * The unique ID existing folder to assign the short link to.
   */
  folderId?: string | null | undefined;
  /**
   * The comments for the short link.
   */
  comments?: string | null | undefined;
  /**
   * The date and time when the short link will expire at.
   */
  expiresAt?: string | null | undefined;
  /**
   * The URL to redirect to when the short link has expired.
   */
  expiredUrl?: string | null | undefined;
  /**
   * The password required to access the destination URL of the short link.
   */
  password?: string | null | undefined;
  /**
   * Whether the short link uses Custom Link Previews feature. Defaults to `false` if not provided.
   */
  proxy?: boolean | undefined;
  /**
   * The custom link preview title (og:title). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  title?: string | null | undefined;
  /**
   * The custom link preview description (og:description). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  description?: string | null | undefined;
  /**
   * The custom link preview image (og:image). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  image?: string | null | undefined;
  /**
   * The custom link preview video (og:video). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  video?: string | null | undefined;
  /**
   * Whether the short link uses link cloaking. Defaults to `false` if not provided.
   */
  rewrite?: boolean | undefined;
  /**
   * The iOS destination URL for the short link for iOS device targeting.
   */
  ios?: string | null | undefined;
  /**
   * The Android destination URL for the short link for Android device targeting.
   */
  android?: string | null | undefined;
  /**
   * Geo targeting information for the short link in JSON format `{[COUNTRY]: https://example.com }`.
   */
  geo?: components.LinkGeoTargeting | null | undefined;
  /**
   * Allow search engines to index your short link. Defaults to `false` if not provided. Learn more: https://d.to/noindex
   */
  doIndex?: boolean | undefined;
  /**
   * The UTM source of the short link. If set, this will populate or override the UTM source in the destination URL.
   */
  utmSource?: string | null | undefined;
  /**
   * The UTM medium of the short link. If set, this will populate or override the UTM medium in the destination URL.
   */
  utmMedium?: string | null | undefined;
  /**
   * The UTM campaign of the short link. If set, this will populate or override the UTM campaign in the destination URL.
   */
  utmCampaign?: string | null | undefined;
  /**
   * The UTM term of the short link. If set, this will populate or override the UTM term in the destination URL.
   */
  utmTerm?: string | null | undefined;
  /**
   * The UTM content of the short link. If set, this will populate or override the UTM content in the destination URL.
   */
  utmContent?: string | null | undefined;
  /**
   * The referral tag of the short link. If set, this will populate or override the `ref` query parameter in the destination URL.
   */
  ref?: string | null | undefined;
  /**
   * An array of webhook IDs to trigger when the link is clicked. These webhooks will receive click event data.
   */
  webhookIds?: Array<string> | null | undefined;
  /**
   * An array of A/B test URLs and the percentage of traffic to send to each URL.
   */
  testVariants?: Array<BulkUpdateLinksTestVariants> | null | undefined;
  /**
   * The date and time when the tests started.
   */
  testStartedAt?: string | null | undefined;
  /**
   * The date and time when the tests were or will be completed.
   */
  testCompletedAt?: string | null | undefined;
};

export type BulkUpdateLinksRequestBody = {
  /**
   * The IDs of the links to update. Takes precedence over `externalIds`.
   */
  linkIds?: Array<string> | undefined;
  /**
   * The external IDs of the links to update as stored in your database.
   */
  externalIds?: Array<string> | undefined;
  data: Data;
};

/** @internal */
export const BulkUpdateLinksTagIds$inboundSchema: z.ZodType<
  BulkUpdateLinksTagIds,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type BulkUpdateLinksTagIds$Outbound = string | Array<string>;

/** @internal */
export const BulkUpdateLinksTagIds$outboundSchema: z.ZodType<
  BulkUpdateLinksTagIds$Outbound,
  z.ZodTypeDef,
  BulkUpdateLinksTagIds
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateLinksTagIds$ {
  /** @deprecated use `BulkUpdateLinksTagIds$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateLinksTagIds$inboundSchema;
  /** @deprecated use `BulkUpdateLinksTagIds$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateLinksTagIds$outboundSchema;
  /** @deprecated use `BulkUpdateLinksTagIds$Outbound` instead. */
  export type Outbound = BulkUpdateLinksTagIds$Outbound;
}

export function bulkUpdateLinksTagIdsToJSON(
  bulkUpdateLinksTagIds: BulkUpdateLinksTagIds,
): string {
  return JSON.stringify(
    BulkUpdateLinksTagIds$outboundSchema.parse(bulkUpdateLinksTagIds),
  );
}

export function bulkUpdateLinksTagIdsFromJSON(
  jsonString: string,
): SafeParseResult<BulkUpdateLinksTagIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateLinksTagIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateLinksTagIds' from JSON`,
  );
}

/** @internal */
export const BulkUpdateLinksTagNames$inboundSchema: z.ZodType<
  BulkUpdateLinksTagNames,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type BulkUpdateLinksTagNames$Outbound = string | Array<string>;

/** @internal */
export const BulkUpdateLinksTagNames$outboundSchema: z.ZodType<
  BulkUpdateLinksTagNames$Outbound,
  z.ZodTypeDef,
  BulkUpdateLinksTagNames
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateLinksTagNames$ {
  /** @deprecated use `BulkUpdateLinksTagNames$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateLinksTagNames$inboundSchema;
  /** @deprecated use `BulkUpdateLinksTagNames$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateLinksTagNames$outboundSchema;
  /** @deprecated use `BulkUpdateLinksTagNames$Outbound` instead. */
  export type Outbound = BulkUpdateLinksTagNames$Outbound;
}

export function bulkUpdateLinksTagNamesToJSON(
  bulkUpdateLinksTagNames: BulkUpdateLinksTagNames,
): string {
  return JSON.stringify(
    BulkUpdateLinksTagNames$outboundSchema.parse(bulkUpdateLinksTagNames),
  );
}

export function bulkUpdateLinksTagNamesFromJSON(
  jsonString: string,
): SafeParseResult<BulkUpdateLinksTagNames, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateLinksTagNames$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateLinksTagNames' from JSON`,
  );
}

/** @internal */
export const BulkUpdateLinksTestVariants$inboundSchema: z.ZodType<
  BulkUpdateLinksTestVariants,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/** @internal */
export type BulkUpdateLinksTestVariants$Outbound = {
  url: string;
  percentage: number;
};

/** @internal */
export const BulkUpdateLinksTestVariants$outboundSchema: z.ZodType<
  BulkUpdateLinksTestVariants$Outbound,
  z.ZodTypeDef,
  BulkUpdateLinksTestVariants
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateLinksTestVariants$ {
  /** @deprecated use `BulkUpdateLinksTestVariants$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateLinksTestVariants$inboundSchema;
  /** @deprecated use `BulkUpdateLinksTestVariants$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateLinksTestVariants$outboundSchema;
  /** @deprecated use `BulkUpdateLinksTestVariants$Outbound` instead. */
  export type Outbound = BulkUpdateLinksTestVariants$Outbound;
}

export function bulkUpdateLinksTestVariantsToJSON(
  bulkUpdateLinksTestVariants: BulkUpdateLinksTestVariants,
): string {
  return JSON.stringify(
    BulkUpdateLinksTestVariants$outboundSchema.parse(
      bulkUpdateLinksTestVariants,
    ),
  );
}

export function bulkUpdateLinksTestVariantsFromJSON(
  jsonString: string,
): SafeParseResult<BulkUpdateLinksTestVariants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateLinksTestVariants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateLinksTestVariants' from JSON`,
  );
}

/** @internal */
export const Data$inboundSchema: z.ZodType<Data, z.ZodTypeDef, unknown> = z
  .object({
    url: z.string().optional(),
    tenantId: z.nullable(z.string()).optional(),
    programId: z.nullable(z.string()).optional(),
    partnerId: z.nullable(z.string()).optional(),
    trackConversion: z.boolean().optional(),
    archived: z.boolean().optional(),
    publicStats: z.boolean().optional(),
    tagId: z.nullable(z.string()).optional(),
    tagIds: z.union([z.string(), z.array(z.string())]).optional(),
    tagNames: z.union([z.string(), z.array(z.string())]).optional(),
    folderId: z.nullable(z.string()).optional(),
    comments: z.nullable(z.string()).optional(),
    expiresAt: z.nullable(z.string()).optional(),
    expiredUrl: z.nullable(z.string()).optional(),
    password: z.nullable(z.string()).optional(),
    proxy: z.boolean().optional(),
    title: z.nullable(z.string()).optional(),
    description: z.nullable(z.string()).optional(),
    image: z.nullable(z.string()).optional(),
    video: z.nullable(z.string()).optional(),
    rewrite: z.boolean().optional(),
    ios: z.nullable(z.string()).optional(),
    android: z.nullable(z.string()).optional(),
    geo: z.nullable(components.LinkGeoTargeting$inboundSchema).optional(),
    doIndex: z.boolean().optional(),
    utm_source: z.nullable(z.string()).optional(),
    utm_medium: z.nullable(z.string()).optional(),
    utm_campaign: z.nullable(z.string()).optional(),
    utm_term: z.nullable(z.string()).optional(),
    utm_content: z.nullable(z.string()).optional(),
    ref: z.nullable(z.string()).optional(),
    webhookIds: z.nullable(z.array(z.string())).optional(),
    testVariants: z.nullable(
      z.array(z.lazy(() => BulkUpdateLinksTestVariants$inboundSchema)),
    ).optional(),
    testStartedAt: z.nullable(z.string()).optional(),
    testCompletedAt: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "utm_source": "utmSource",
      "utm_medium": "utmMedium",
      "utm_campaign": "utmCampaign",
      "utm_term": "utmTerm",
      "utm_content": "utmContent",
    });
  });

/** @internal */
export type Data$Outbound = {
  url?: string | undefined;
  tenantId?: string | null | undefined;
  programId?: string | null | undefined;
  partnerId?: string | null | undefined;
  trackConversion?: boolean | undefined;
  archived?: boolean | undefined;
  publicStats?: boolean | undefined;
  tagId?: string | null | undefined;
  tagIds?: string | Array<string> | undefined;
  tagNames?: string | Array<string> | undefined;
  folderId?: string | null | undefined;
  comments?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredUrl?: string | null | undefined;
  password?: string | null | undefined;
  proxy?: boolean | undefined;
  title?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  video?: string | null | undefined;
  rewrite?: boolean | undefined;
  ios?: string | null | undefined;
  android?: string | null | undefined;
  geo?: components.LinkGeoTargeting$Outbound | null | undefined;
  doIndex?: boolean | undefined;
  utm_source?: string | null | undefined;
  utm_medium?: string | null | undefined;
  utm_campaign?: string | null | undefined;
  utm_term?: string | null | undefined;
  utm_content?: string | null | undefined;
  ref?: string | null | undefined;
  webhookIds?: Array<string> | null | undefined;
  testVariants?: Array<BulkUpdateLinksTestVariants$Outbound> | null | undefined;
  testStartedAt?: string | null | undefined;
  testCompletedAt?: string | null | undefined;
};

/** @internal */
export const Data$outboundSchema: z.ZodType<Data$Outbound, z.ZodTypeDef, Data> =
  z.object({
    url: z.string().optional(),
    tenantId: z.nullable(z.string()).optional(),
    programId: z.nullable(z.string()).optional(),
    partnerId: z.nullable(z.string()).optional(),
    trackConversion: z.boolean().optional(),
    archived: z.boolean().optional(),
    publicStats: z.boolean().optional(),
    tagId: z.nullable(z.string()).optional(),
    tagIds: z.union([z.string(), z.array(z.string())]).optional(),
    tagNames: z.union([z.string(), z.array(z.string())]).optional(),
    folderId: z.nullable(z.string()).optional(),
    comments: z.nullable(z.string()).optional(),
    expiresAt: z.nullable(z.string()).optional(),
    expiredUrl: z.nullable(z.string()).optional(),
    password: z.nullable(z.string()).optional(),
    proxy: z.boolean().optional(),
    title: z.nullable(z.string()).optional(),
    description: z.nullable(z.string()).optional(),
    image: z.nullable(z.string()).optional(),
    video: z.nullable(z.string()).optional(),
    rewrite: z.boolean().optional(),
    ios: z.nullable(z.string()).optional(),
    android: z.nullable(z.string()).optional(),
    geo: z.nullable(components.LinkGeoTargeting$outboundSchema).optional(),
    doIndex: z.boolean().optional(),
    utmSource: z.nullable(z.string()).optional(),
    utmMedium: z.nullable(z.string()).optional(),
    utmCampaign: z.nullable(z.string()).optional(),
    utmTerm: z.nullable(z.string()).optional(),
    utmContent: z.nullable(z.string()).optional(),
    ref: z.nullable(z.string()).optional(),
    webhookIds: z.nullable(z.array(z.string())).optional(),
    testVariants: z.nullable(
      z.array(z.lazy(() => BulkUpdateLinksTestVariants$outboundSchema)),
    ).optional(),
    testStartedAt: z.nullable(z.string()).optional(),
    testCompletedAt: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      utmSource: "utm_source",
      utmMedium: "utm_medium",
      utmCampaign: "utm_campaign",
      utmTerm: "utm_term",
      utmContent: "utm_content",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data$ {
  /** @deprecated use `Data$inboundSchema` instead. */
  export const inboundSchema = Data$inboundSchema;
  /** @deprecated use `Data$outboundSchema` instead. */
  export const outboundSchema = Data$outboundSchema;
  /** @deprecated use `Data$Outbound` instead. */
  export type Outbound = Data$Outbound;
}

export function dataToJSON(data: Data): string {
  return JSON.stringify(Data$outboundSchema.parse(data));
}

export function dataFromJSON(
  jsonString: string,
): SafeParseResult<Data, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data' from JSON`,
  );
}

/** @internal */
export const BulkUpdateLinksRequestBody$inboundSchema: z.ZodType<
  BulkUpdateLinksRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  linkIds: z.array(z.string()).optional(),
  externalIds: z.array(z.string()).optional(),
  data: z.lazy(() => Data$inboundSchema),
});

/** @internal */
export type BulkUpdateLinksRequestBody$Outbound = {
  linkIds?: Array<string> | undefined;
  externalIds?: Array<string> | undefined;
  data: Data$Outbound;
};

/** @internal */
export const BulkUpdateLinksRequestBody$outboundSchema: z.ZodType<
  BulkUpdateLinksRequestBody$Outbound,
  z.ZodTypeDef,
  BulkUpdateLinksRequestBody
> = z.object({
  linkIds: z.array(z.string()).optional(),
  externalIds: z.array(z.string()).optional(),
  data: z.lazy(() => Data$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateLinksRequestBody$ {
  /** @deprecated use `BulkUpdateLinksRequestBody$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateLinksRequestBody$inboundSchema;
  /** @deprecated use `BulkUpdateLinksRequestBody$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateLinksRequestBody$outboundSchema;
  /** @deprecated use `BulkUpdateLinksRequestBody$Outbound` instead. */
  export type Outbound = BulkUpdateLinksRequestBody$Outbound;
}

export function bulkUpdateLinksRequestBodyToJSON(
  bulkUpdateLinksRequestBody: BulkUpdateLinksRequestBody,
): string {
  return JSON.stringify(
    BulkUpdateLinksRequestBody$outboundSchema.parse(bulkUpdateLinksRequestBody),
  );
}

export function bulkUpdateLinksRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<BulkUpdateLinksRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateLinksRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateLinksRequestBody' from JSON`,
  );
}
