/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Useful for marking a commission as refunded, duplicate, canceled, or fraudulent. Takes precedence over `amount` and `modifyAmount`. When a commission is marked as refunded, duplicate, canceled, or fraudulent, it will be omitted from the payout, and the payout amount will be recalculated accordingly. Paid commissions cannot be updated.
 */
export const Status = {
  Refunded: "refunded",
  Duplicate: "duplicate",
  Canceled: "canceled",
  Fraud: "fraud",
} as const;
/**
 * Useful for marking a commission as refunded, duplicate, canceled, or fraudulent. Takes precedence over `amount` and `modifyAmount`. When a commission is marked as refunded, duplicate, canceled, or fraudulent, it will be omitted from the payout, and the payout amount will be recalculated accordingly. Paid commissions cannot be updated.
 */
export type Status = ClosedEnum<typeof Status>;

export type UpdateCommissionRequestBody = {
  /**
   * The new absolute amount for the sale. Paid commissions cannot be updated.
   */
  amount?: number | undefined;
  /**
   * Modify the current sale amount: use positive values to increase the amount, negative values to decrease it. Takes precedence over `amount`. Paid commissions cannot be updated.
   */
  modifyAmount?: number | undefined;
  /**
   * The currency of the sale amount to update. Accepts ISO 4217 currency codes.
   */
  currency?: string | undefined;
  /**
   * Useful for marking a commission as refunded, duplicate, canceled, or fraudulent. Takes precedence over `amount` and `modifyAmount`. When a commission is marked as refunded, duplicate, canceled, or fraudulent, it will be omitted from the payout, and the payout amount will be recalculated accordingly. Paid commissions cannot be updated.
   */
  status?: Status | undefined;
};

export type UpdateCommissionRequest = {
  /**
   * The commission's unique ID on Dub.
   */
  id: string;
  requestBody?: UpdateCommissionRequestBody | undefined;
};

export const UpdateCommissionType = {
  Click: "click",
  Lead: "lead",
  Sale: "sale",
  Custom: "custom",
} as const;
export type UpdateCommissionType = ClosedEnum<typeof UpdateCommissionType>;

export const UpdateCommissionStatus = {
  Pending: "pending",
  Processed: "processed",
  Paid: "paid",
  Refunded: "refunded",
  Duplicate: "duplicate",
  Fraud: "fraud",
  Canceled: "canceled",
} as const;
export type UpdateCommissionStatus = ClosedEnum<typeof UpdateCommissionStatus>;

export type UpdateCommissionPartner = {
  /**
   * The partner's unique ID on Dub.
   */
  id: string;
  /**
   * The partner's full legal name.
   */
  name: string;
  /**
   * The partner's email address. Should be a unique value across Dub.
   */
  email: string | null;
  /**
   * The partner's avatar image.
   */
  image: string | null;
  /**
   * The date when the partner enabled payouts.
   */
  payoutsEnabledAt: string | null;
  /**
   * The partner's country (required for tax purposes).
   */
  country: string | null;
  /**
   * The partner's group ID on Dub.
   */
  groupId?: string | null | undefined;
};

export type UpdateCommissionCustomer = {
  /**
   * The unique ID of the customer. You may use either the customer's `id` on Dub (obtained via `/customers` endpoint) or their `externalId` (unique ID within your system, prefixed with `ext_`, e.g. `ext_123`).
   */
  id: string;
  /**
   * Unique identifier for the customer in the client's app.
   */
  externalId: string;
  /**
   * Name of the customer.
   */
  name: string;
  /**
   * Email of the customer.
   */
  email?: string | null | undefined;
  /**
   * Avatar URL of the customer.
   */
  avatar?: string | null | undefined;
  /**
   * Country of the customer.
   */
  country?: string | null | undefined;
  /**
   * Total number of sales for the customer.
   */
  sales?: number | null | undefined;
  /**
   * Total amount of sales for the customer.
   */
  saleAmount?: number | null | undefined;
  /**
   * The date the customer was created.
   */
  createdAt: string;
};

/**
 * The updated commission.
 */
export type UpdateCommissionResponseBody = {
  /**
   * The commission's unique ID on Dub.
   */
  id: string;
  type?: UpdateCommissionType | undefined;
  amount: number;
  earnings: number;
  currency: string;
  status: UpdateCommissionStatus;
  invoiceId: string | null;
  description: string | null;
  quantity: number;
  /**
   * The user who created the manual commission.
   */
  userId?: string | null | undefined;
  createdAt: string;
  updatedAt: string;
  partner: UpdateCommissionPartner;
  customer?: UpdateCommissionCustomer | null | undefined;
};

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export type UpdateCommissionRequestBody$Outbound = {
  amount?: number | undefined;
  modifyAmount?: number | undefined;
  currency: string;
  status?: string | undefined;
};

/** @internal */
export const UpdateCommissionRequestBody$outboundSchema: z.ZodType<
  UpdateCommissionRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateCommissionRequestBody
> = z.object({
  amount: z.number().optional(),
  modifyAmount: z.number().optional(),
  currency: z.string().default("usd"),
  status: Status$outboundSchema.optional(),
});

export function updateCommissionRequestBodyToJSON(
  updateCommissionRequestBody: UpdateCommissionRequestBody,
): string {
  return JSON.stringify(
    UpdateCommissionRequestBody$outboundSchema.parse(
      updateCommissionRequestBody,
    ),
  );
}

/** @internal */
export type UpdateCommissionRequest$Outbound = {
  id: string;
  RequestBody?: UpdateCommissionRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateCommissionRequest$outboundSchema: z.ZodType<
  UpdateCommissionRequest$Outbound,
  z.ZodTypeDef,
  UpdateCommissionRequest
> = z.object({
  id: z.string(),
  requestBody: z.lazy(() => UpdateCommissionRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateCommissionRequestToJSON(
  updateCommissionRequest: UpdateCommissionRequest,
): string {
  return JSON.stringify(
    UpdateCommissionRequest$outboundSchema.parse(updateCommissionRequest),
  );
}

/** @internal */
export const UpdateCommissionType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateCommissionType
> = z.nativeEnum(UpdateCommissionType);

/** @internal */
export const UpdateCommissionStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateCommissionStatus
> = z.nativeEnum(UpdateCommissionStatus);

/** @internal */
export const UpdateCommissionPartner$inboundSchema: z.ZodType<
  UpdateCommissionPartner,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
  email: z.nullable(z.string()),
  image: z.nullable(z.string()),
  payoutsEnabledAt: z.nullable(z.string()),
  country: z.nullable(z.string()),
  groupId: z.nullable(z.string()).optional(),
});

export function updateCommissionPartnerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCommissionPartner, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCommissionPartner$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCommissionPartner' from JSON`,
  );
}

/** @internal */
export const UpdateCommissionCustomer$inboundSchema: z.ZodType<
  UpdateCommissionCustomer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  externalId: z.string(),
  name: z.string(),
  email: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  sales: z.nullable(z.number()).optional(),
  saleAmount: z.nullable(z.number()).optional(),
  createdAt: z.string(),
});

export function updateCommissionCustomerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCommissionCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCommissionCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCommissionCustomer' from JSON`,
  );
}

/** @internal */
export const UpdateCommissionResponseBody$inboundSchema: z.ZodType<
  UpdateCommissionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: UpdateCommissionType$inboundSchema.optional(),
  amount: z.number(),
  earnings: z.number(),
  currency: z.string(),
  status: UpdateCommissionStatus$inboundSchema,
  invoiceId: z.nullable(z.string()),
  description: z.nullable(z.string()),
  quantity: z.number(),
  userId: z.nullable(z.string()).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
  partner: z.lazy(() => UpdateCommissionPartner$inboundSchema),
  customer: z.nullable(z.lazy(() => UpdateCommissionCustomer$inboundSchema))
    .optional(),
});

export function updateCommissionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCommissionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCommissionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCommissionResponseBody' from JSON`,
  );
}
