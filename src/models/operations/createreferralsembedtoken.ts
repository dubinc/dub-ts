/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The partner's country of residence. Must be passed as a 2-letter ISO 3166-1 country code. Learn more: https://d.to/geo
 */
export const CreateReferralsEmbedTokenCountry = {
  Af: "AF",
  Al: "AL",
  Dz: "DZ",
  As: "AS",
  Ad: "AD",
  Ao: "AO",
  Ai: "AI",
  Aq: "AQ",
  Ag: "AG",
  Ar: "AR",
  Am: "AM",
  Aw: "AW",
  Au: "AU",
  At: "AT",
  Az: "AZ",
  Bs: "BS",
  Bh: "BH",
  Bd: "BD",
  Bb: "BB",
  By: "BY",
  Be: "BE",
  Bz: "BZ",
  Bj: "BJ",
  Bm: "BM",
  Bt: "BT",
  Bo: "BO",
  Ba: "BA",
  Bw: "BW",
  Bv: "BV",
  Br: "BR",
  Io: "IO",
  Bn: "BN",
  Bg: "BG",
  Bf: "BF",
  Bi: "BI",
  Kh: "KH",
  Cm: "CM",
  Ca: "CA",
  Cv: "CV",
  Ky: "KY",
  Cf: "CF",
  Td: "TD",
  Cl: "CL",
  Cn: "CN",
  Cx: "CX",
  Cc: "CC",
  Co: "CO",
  Km: "KM",
  Cg: "CG",
  Cd: "CD",
  Ck: "CK",
  Cr: "CR",
  Ci: "CI",
  Hr: "HR",
  Cu: "CU",
  Cy: "CY",
  Cz: "CZ",
  Dk: "DK",
  Dj: "DJ",
  Dm: "DM",
  Do: "DO",
  Ec: "EC",
  Eg: "EG",
  Sv: "SV",
  Gq: "GQ",
  Er: "ER",
  Ee: "EE",
  Et: "ET",
  Fk: "FK",
  Fo: "FO",
  Fj: "FJ",
  Fi: "FI",
  Fr: "FR",
  Gf: "GF",
  Pf: "PF",
  Tf: "TF",
  Ga: "GA",
  Gm: "GM",
  Ge: "GE",
  De: "DE",
  Gh: "GH",
  Gi: "GI",
  Gr: "GR",
  Gl: "GL",
  Gd: "GD",
  Gp: "GP",
  Gu: "GU",
  Gt: "GT",
  Gn: "GN",
  Gw: "GW",
  Gy: "GY",
  Ht: "HT",
  Hm: "HM",
  Va: "VA",
  Hn: "HN",
  Hk: "HK",
  Hu: "HU",
  Is: "IS",
  In: "IN",
  Id: "ID",
  Ir: "IR",
  Iq: "IQ",
  Ie: "IE",
  Il: "IL",
  It: "IT",
  Jm: "JM",
  Jp: "JP",
  Jo: "JO",
  Kz: "KZ",
  Ke: "KE",
  Ki: "KI",
  Kp: "KP",
  Kr: "KR",
  Kw: "KW",
  Kg: "KG",
  La: "LA",
  Lv: "LV",
  Lb: "LB",
  Ls: "LS",
  Lr: "LR",
  Ly: "LY",
  Li: "LI",
  Lt: "LT",
  Lu: "LU",
  Mo: "MO",
  Mg: "MG",
  Mw: "MW",
  My: "MY",
  Mv: "MV",
  Ml: "ML",
  Mt: "MT",
  Mh: "MH",
  Mq: "MQ",
  Mr: "MR",
  Mu: "MU",
  Yt: "YT",
  Mx: "MX",
  Fm: "FM",
  Md: "MD",
  Mc: "MC",
  Mn: "MN",
  Ms: "MS",
  Ma: "MA",
  Mz: "MZ",
  Mm: "MM",
  Na: "NA",
  Nr: "NR",
  Np: "NP",
  Nl: "NL",
  Nc: "NC",
  Nz: "NZ",
  Ni: "NI",
  Ne: "NE",
  Ng: "NG",
  Nu: "NU",
  Nf: "NF",
  Mk: "MK",
  Mp: "MP",
  No: "NO",
  Om: "OM",
  Pk: "PK",
  Pw: "PW",
  Ps: "PS",
  Pa: "PA",
  Pg: "PG",
  Py: "PY",
  Pe: "PE",
  Ph: "PH",
  Pn: "PN",
  Pl: "PL",
  Pt: "PT",
  Pr: "PR",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Ru: "RU",
  Rw: "RW",
  Sh: "SH",
  Kn: "KN",
  Lc: "LC",
  Pm: "PM",
  Vc: "VC",
  Ws: "WS",
  Sm: "SM",
  St: "ST",
  Sa: "SA",
  Sn: "SN",
  Sc: "SC",
  Sl: "SL",
  Sg: "SG",
  Sk: "SK",
  Si: "SI",
  Sb: "SB",
  So: "SO",
  Za: "ZA",
  Gs: "GS",
  Es: "ES",
  Lk: "LK",
  Sd: "SD",
  Sr: "SR",
  Sj: "SJ",
  Sz: "SZ",
  Se: "SE",
  Ch: "CH",
  Sy: "SY",
  Tw: "TW",
  Tj: "TJ",
  Tz: "TZ",
  Th: "TH",
  Tl: "TL",
  Tg: "TG",
  Tk: "TK",
  To: "TO",
  Tt: "TT",
  Tn: "TN",
  Tr: "TR",
  Tm: "TM",
  Tc: "TC",
  Tv: "TV",
  Ug: "UG",
  Ua: "UA",
  Ae: "AE",
  Gb: "GB",
  Us: "US",
  Um: "UM",
  Uy: "UY",
  Uz: "UZ",
  Vu: "VU",
  Ve: "VE",
  Vn: "VN",
  Vg: "VG",
  Vi: "VI",
  Wf: "WF",
  Eh: "EH",
  Ye: "YE",
  Zm: "ZM",
  Zw: "ZW",
  Ax: "AX",
  Bq: "BQ",
  Cw: "CW",
  Gg: "GG",
  Im: "IM",
  Je: "JE",
  Me: "ME",
  Bl: "BL",
  Mf: "MF",
  Rs: "RS",
  Sx: "SX",
  Ss: "SS",
  Xk: "XK",
} as const;
/**
 * The partner's country of residence. Must be passed as a 2-letter ISO 3166-1 country code. Learn more: https://d.to/geo
 */
export type CreateReferralsEmbedTokenCountry = ClosedEnum<
  typeof CreateReferralsEmbedTokenCountry
>;

/**
 * The unique IDs of the tags assigned to the short link.
 */
export type CreateReferralsEmbedTokenTagIds = string | Array<string>;

/**
 * The unique name of the tags assigned to the short link (case insensitive).
 */
export type CreateReferralsEmbedTokenTagNames = string | Array<string>;

export type CreateReferralsEmbedTokenTestVariants = {
  url: string;
  percentage: number;
};

/**
 * Additional properties that you can pass to the partner's short link. Will be used to override the default link properties for this partner.
 */
export type CreateReferralsEmbedTokenLinkProps = {
  /**
   * The length of the short link slug. Defaults to 7 if not provided. When used with `prefix`, the total length of the key will be `prefix.length + keyLength`.
   */
  keyLength?: number | undefined;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId?: string | null | undefined;
  /**
   * The ID of the tenant that created the link inside your system. If set, it can be used to fetch all links for a tenant.
   */
  tenantId?: string | null | undefined;
  /**
   * The prefix of the short link slug for randomly-generated keys (e.g. if prefix is `/c/`, generated keys will be in the `/c/:key` format). Will be ignored if `key` is provided.
   */
  prefix?: string | undefined;
  /**
   * Whether the short link is archived. Defaults to `false` if not provided.
   */
  archived?: boolean | undefined;
  /**
   * The unique IDs of the tags assigned to the short link.
   */
  tagIds?: string | Array<string> | undefined;
  /**
   * The unique name of the tags assigned to the short link (case insensitive).
   */
  tagNames?: string | Array<string> | undefined;
  /**
   * The unique ID existing folder to assign the short link to.
   */
  folderId?: string | null | undefined;
  /**
   * The comments for the short link.
   */
  comments?: string | null | undefined;
  /**
   * The date and time when the short link will expire at.
   */
  expiresAt?: string | null | undefined;
  /**
   * The URL to redirect to when the short link has expired.
   */
  expiredUrl?: string | null | undefined;
  /**
   * The password required to access the destination URL of the short link.
   */
  password?: string | null | undefined;
  /**
   * Whether the short link uses Custom Link Previews feature. Defaults to `false` if not provided.
   */
  proxy?: boolean | undefined;
  /**
   * The custom link preview title (og:title). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  title?: string | null | undefined;
  /**
   * The custom link preview description (og:description). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  description?: string | null | undefined;
  /**
   * The custom link preview image (og:image). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  image?: string | null | undefined;
  /**
   * The custom link preview video (og:video). Will be used for Custom Link Previews if `proxy` is true. Learn more: https://d.to/og
   */
  video?: string | null | undefined;
  /**
   * Whether the short link uses link cloaking. Defaults to `false` if not provided.
   */
  rewrite?: boolean | undefined;
  /**
   * The iOS destination URL for the short link for iOS device targeting.
   */
  ios?: string | null | undefined;
  /**
   * The Android destination URL for the short link for Android device targeting.
   */
  android?: string | null | undefined;
  /**
   * Allow search engines to index your short link. Defaults to `false` if not provided. Learn more: https://d.to/noindex
   */
  doIndex?: boolean | undefined;
  /**
   * The UTM source of the short link. If set, this will populate or override the UTM source in the destination URL.
   */
  utmSource?: string | null | undefined;
  /**
   * The UTM medium of the short link. If set, this will populate or override the UTM medium in the destination URL.
   */
  utmMedium?: string | null | undefined;
  /**
   * The UTM campaign of the short link. If set, this will populate or override the UTM campaign in the destination URL.
   */
  utmCampaign?: string | null | undefined;
  /**
   * The UTM term of the short link. If set, this will populate or override the UTM term in the destination URL.
   */
  utmTerm?: string | null | undefined;
  /**
   * The UTM content of the short link. If set, this will populate or override the UTM content in the destination URL.
   */
  utmContent?: string | null | undefined;
  /**
   * The referral tag of the short link. If set, this will populate or override the `ref` query parameter in the destination URL.
   */
  ref?: string | null | undefined;
  /**
   * An array of A/B test URLs and the percentage of traffic to send to each URL.
   */
  testVariants?:
    | Array<CreateReferralsEmbedTokenTestVariants>
    | null
    | undefined;
  /**
   * The date and time when the tests started.
   */
  testStartedAt?: string | null | undefined;
  /**
   * The date and time when the tests were or will be completed.
   */
  testCompletedAt?: string | null | undefined;
};

export type Partner = {
  /**
   * The partner's full name. If undefined, the partner's email will be used in lieu of their name (e.g. `john@acme.com`)
   */
  name?: string | null | undefined;
  /**
   * The partner's email address. Partners will be able to claim their profile by signing up at `partners.dub.co` with this email.
   */
  email: string;
  /**
   * The partner's unique username in your system (max 100 characters). This will be used to create a short link for the partner using your program's default domain. If not provided, Dub will try to generate a username from the partner's name or email.
   */
  username?: string | null | undefined;
  /**
   * The partner's avatar image. If not provided, a default avatar will be used.
   */
  image?: string | null | undefined;
  /**
   * The partner's unique ID in your system. Useful for retrieving the partner's links and stats later on. If not provided, the partner will be created as a standalone partner.
   */
  tenantId?: string | undefined;
  /**
   * The partner's country of residence. Must be passed as a 2-letter ISO 3166-1 country code. Learn more: https://d.to/geo
   */
  country?: CreateReferralsEmbedTokenCountry | null | undefined;
  /**
   * A brief description of the partner and their background. Max 5,000 characters.
   */
  description?: string | null | undefined;
  /**
   * Additional properties that you can pass to the partner's short link. Will be used to override the default link properties for this partner.
   */
  linkProps?: CreateReferralsEmbedTokenLinkProps | undefined;
};

export type CreateReferralsEmbedTokenRequestBody = {
  partnerId?: string | undefined;
  tenantId?: string | undefined;
  partner?: Partner | undefined;
};

/**
 * The created public embed token.
 */
export type CreateReferralsEmbedTokenResponseBody = {
  publicToken: string;
  expires: string;
};

/** @internal */
export const CreateReferralsEmbedTokenCountry$inboundSchema: z.ZodNativeEnum<
  typeof CreateReferralsEmbedTokenCountry
> = z.nativeEnum(CreateReferralsEmbedTokenCountry);

/** @internal */
export const CreateReferralsEmbedTokenCountry$outboundSchema: z.ZodNativeEnum<
  typeof CreateReferralsEmbedTokenCountry
> = CreateReferralsEmbedTokenCountry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenCountry$ {
  /** @deprecated use `CreateReferralsEmbedTokenCountry$inboundSchema` instead. */
  export const inboundSchema = CreateReferralsEmbedTokenCountry$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenCountry$outboundSchema` instead. */
  export const outboundSchema = CreateReferralsEmbedTokenCountry$outboundSchema;
}

/** @internal */
export const CreateReferralsEmbedTokenTagIds$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTagIds,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type CreateReferralsEmbedTokenTagIds$Outbound = string | Array<string>;

/** @internal */
export const CreateReferralsEmbedTokenTagIds$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTagIds$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenTagIds
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenTagIds$ {
  /** @deprecated use `CreateReferralsEmbedTokenTagIds$inboundSchema` instead. */
  export const inboundSchema = CreateReferralsEmbedTokenTagIds$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTagIds$outboundSchema` instead. */
  export const outboundSchema = CreateReferralsEmbedTokenTagIds$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTagIds$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenTagIds$Outbound;
}

export function createReferralsEmbedTokenTagIdsToJSON(
  createReferralsEmbedTokenTagIds: CreateReferralsEmbedTokenTagIds,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenTagIds$outboundSchema.parse(
      createReferralsEmbedTokenTagIds,
    ),
  );
}

export function createReferralsEmbedTokenTagIdsFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenTagIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateReferralsEmbedTokenTagIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenTagIds' from JSON`,
  );
}

/** @internal */
export const CreateReferralsEmbedTokenTagNames$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTagNames,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type CreateReferralsEmbedTokenTagNames$Outbound = string | Array<string>;

/** @internal */
export const CreateReferralsEmbedTokenTagNames$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTagNames$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenTagNames
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenTagNames$ {
  /** @deprecated use `CreateReferralsEmbedTokenTagNames$inboundSchema` instead. */
  export const inboundSchema = CreateReferralsEmbedTokenTagNames$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTagNames$outboundSchema` instead. */
  export const outboundSchema =
    CreateReferralsEmbedTokenTagNames$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTagNames$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenTagNames$Outbound;
}

export function createReferralsEmbedTokenTagNamesToJSON(
  createReferralsEmbedTokenTagNames: CreateReferralsEmbedTokenTagNames,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenTagNames$outboundSchema.parse(
      createReferralsEmbedTokenTagNames,
    ),
  );
}

export function createReferralsEmbedTokenTagNamesFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenTagNames, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateReferralsEmbedTokenTagNames$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenTagNames' from JSON`,
  );
}

/** @internal */
export const CreateReferralsEmbedTokenTestVariants$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTestVariants,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/** @internal */
export type CreateReferralsEmbedTokenTestVariants$Outbound = {
  url: string;
  percentage: number;
};

/** @internal */
export const CreateReferralsEmbedTokenTestVariants$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenTestVariants$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenTestVariants
> = z.object({
  url: z.string(),
  percentage: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenTestVariants$ {
  /** @deprecated use `CreateReferralsEmbedTokenTestVariants$inboundSchema` instead. */
  export const inboundSchema =
    CreateReferralsEmbedTokenTestVariants$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTestVariants$outboundSchema` instead. */
  export const outboundSchema =
    CreateReferralsEmbedTokenTestVariants$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenTestVariants$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenTestVariants$Outbound;
}

export function createReferralsEmbedTokenTestVariantsToJSON(
  createReferralsEmbedTokenTestVariants: CreateReferralsEmbedTokenTestVariants,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenTestVariants$outboundSchema.parse(
      createReferralsEmbedTokenTestVariants,
    ),
  );
}

export function createReferralsEmbedTokenTestVariantsFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenTestVariants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateReferralsEmbedTokenTestVariants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenTestVariants' from JSON`,
  );
}

/** @internal */
export const CreateReferralsEmbedTokenLinkProps$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenLinkProps,
  z.ZodTypeDef,
  unknown
> = z.object({
  keyLength: z.number().optional(),
  externalId: z.nullable(z.string()).optional(),
  tenantId: z.nullable(z.string()).optional(),
  prefix: z.string().optional(),
  archived: z.boolean().optional(),
  tagIds: z.union([z.string(), z.array(z.string())]).optional(),
  tagNames: z.union([z.string(), z.array(z.string())]).optional(),
  folderId: z.nullable(z.string()).optional(),
  comments: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredUrl: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  proxy: z.boolean().optional(),
  title: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  video: z.nullable(z.string()).optional(),
  rewrite: z.boolean().optional(),
  ios: z.nullable(z.string()).optional(),
  android: z.nullable(z.string()).optional(),
  doIndex: z.boolean().optional(),
  utm_source: z.nullable(z.string()).optional(),
  utm_medium: z.nullable(z.string()).optional(),
  utm_campaign: z.nullable(z.string()).optional(),
  utm_term: z.nullable(z.string()).optional(),
  utm_content: z.nullable(z.string()).optional(),
  ref: z.nullable(z.string()).optional(),
  testVariants: z.nullable(
    z.array(z.lazy(() => CreateReferralsEmbedTokenTestVariants$inboundSchema)),
  ).optional(),
  testStartedAt: z.nullable(z.string()).optional(),
  testCompletedAt: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "utm_source": "utmSource",
    "utm_medium": "utmMedium",
    "utm_campaign": "utmCampaign",
    "utm_term": "utmTerm",
    "utm_content": "utmContent",
  });
});

/** @internal */
export type CreateReferralsEmbedTokenLinkProps$Outbound = {
  keyLength?: number | undefined;
  externalId?: string | null | undefined;
  tenantId?: string | null | undefined;
  prefix?: string | undefined;
  archived?: boolean | undefined;
  tagIds?: string | Array<string> | undefined;
  tagNames?: string | Array<string> | undefined;
  folderId?: string | null | undefined;
  comments?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredUrl?: string | null | undefined;
  password?: string | null | undefined;
  proxy?: boolean | undefined;
  title?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  video?: string | null | undefined;
  rewrite?: boolean | undefined;
  ios?: string | null | undefined;
  android?: string | null | undefined;
  doIndex?: boolean | undefined;
  utm_source?: string | null | undefined;
  utm_medium?: string | null | undefined;
  utm_campaign?: string | null | undefined;
  utm_term?: string | null | undefined;
  utm_content?: string | null | undefined;
  ref?: string | null | undefined;
  testVariants?:
    | Array<CreateReferralsEmbedTokenTestVariants$Outbound>
    | null
    | undefined;
  testStartedAt?: string | null | undefined;
  testCompletedAt?: string | null | undefined;
};

/** @internal */
export const CreateReferralsEmbedTokenLinkProps$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenLinkProps$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenLinkProps
> = z.object({
  keyLength: z.number().optional(),
  externalId: z.nullable(z.string()).optional(),
  tenantId: z.nullable(z.string()).optional(),
  prefix: z.string().optional(),
  archived: z.boolean().optional(),
  tagIds: z.union([z.string(), z.array(z.string())]).optional(),
  tagNames: z.union([z.string(), z.array(z.string())]).optional(),
  folderId: z.nullable(z.string()).optional(),
  comments: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredUrl: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  proxy: z.boolean().optional(),
  title: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  video: z.nullable(z.string()).optional(),
  rewrite: z.boolean().optional(),
  ios: z.nullable(z.string()).optional(),
  android: z.nullable(z.string()).optional(),
  doIndex: z.boolean().optional(),
  utmSource: z.nullable(z.string()).optional(),
  utmMedium: z.nullable(z.string()).optional(),
  utmCampaign: z.nullable(z.string()).optional(),
  utmTerm: z.nullable(z.string()).optional(),
  utmContent: z.nullable(z.string()).optional(),
  ref: z.nullable(z.string()).optional(),
  testVariants: z.nullable(
    z.array(z.lazy(() => CreateReferralsEmbedTokenTestVariants$outboundSchema)),
  ).optional(),
  testStartedAt: z.nullable(z.string()).optional(),
  testCompletedAt: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    utmSource: "utm_source",
    utmMedium: "utm_medium",
    utmCampaign: "utm_campaign",
    utmTerm: "utm_term",
    utmContent: "utm_content",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenLinkProps$ {
  /** @deprecated use `CreateReferralsEmbedTokenLinkProps$inboundSchema` instead. */
  export const inboundSchema = CreateReferralsEmbedTokenLinkProps$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenLinkProps$outboundSchema` instead. */
  export const outboundSchema =
    CreateReferralsEmbedTokenLinkProps$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenLinkProps$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenLinkProps$Outbound;
}

export function createReferralsEmbedTokenLinkPropsToJSON(
  createReferralsEmbedTokenLinkProps: CreateReferralsEmbedTokenLinkProps,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenLinkProps$outboundSchema.parse(
      createReferralsEmbedTokenLinkProps,
    ),
  );
}

export function createReferralsEmbedTokenLinkPropsFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenLinkProps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateReferralsEmbedTokenLinkProps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenLinkProps' from JSON`,
  );
}

/** @internal */
export const Partner$inboundSchema: z.ZodType<Partner, z.ZodTypeDef, unknown> =
  z.object({
    name: z.nullable(z.string()).optional(),
    email: z.string(),
    username: z.nullable(z.string()).optional(),
    image: z.nullable(z.string()).optional(),
    tenantId: z.string().optional(),
    country: z.nullable(CreateReferralsEmbedTokenCountry$inboundSchema)
      .optional(),
    description: z.nullable(z.string()).optional(),
    linkProps: z.lazy(() => CreateReferralsEmbedTokenLinkProps$inboundSchema)
      .optional(),
  });

/** @internal */
export type Partner$Outbound = {
  name?: string | null | undefined;
  email: string;
  username?: string | null | undefined;
  image?: string | null | undefined;
  tenantId?: string | undefined;
  country?: string | null | undefined;
  description?: string | null | undefined;
  linkProps?: CreateReferralsEmbedTokenLinkProps$Outbound | undefined;
};

/** @internal */
export const Partner$outboundSchema: z.ZodType<
  Partner$Outbound,
  z.ZodTypeDef,
  Partner
> = z.object({
  name: z.nullable(z.string()).optional(),
  email: z.string(),
  username: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  tenantId: z.string().optional(),
  country: z.nullable(CreateReferralsEmbedTokenCountry$outboundSchema)
    .optional(),
  description: z.nullable(z.string()).optional(),
  linkProps: z.lazy(() => CreateReferralsEmbedTokenLinkProps$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Partner$ {
  /** @deprecated use `Partner$inboundSchema` instead. */
  export const inboundSchema = Partner$inboundSchema;
  /** @deprecated use `Partner$outboundSchema` instead. */
  export const outboundSchema = Partner$outboundSchema;
  /** @deprecated use `Partner$Outbound` instead. */
  export type Outbound = Partner$Outbound;
}

export function partnerToJSON(partner: Partner): string {
  return JSON.stringify(Partner$outboundSchema.parse(partner));
}

export function partnerFromJSON(
  jsonString: string,
): SafeParseResult<Partner, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Partner$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Partner' from JSON`,
  );
}

/** @internal */
export const CreateReferralsEmbedTokenRequestBody$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  partnerId: z.string().optional(),
  tenantId: z.string().optional(),
  partner: z.lazy(() => Partner$inboundSchema).optional(),
});

/** @internal */
export type CreateReferralsEmbedTokenRequestBody$Outbound = {
  partnerId?: string | undefined;
  tenantId?: string | undefined;
  partner?: Partner$Outbound | undefined;
};

/** @internal */
export const CreateReferralsEmbedTokenRequestBody$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenRequestBody$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenRequestBody
> = z.object({
  partnerId: z.string().optional(),
  tenantId: z.string().optional(),
  partner: z.lazy(() => Partner$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenRequestBody$ {
  /** @deprecated use `CreateReferralsEmbedTokenRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    CreateReferralsEmbedTokenRequestBody$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    CreateReferralsEmbedTokenRequestBody$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenRequestBody$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenRequestBody$Outbound;
}

export function createReferralsEmbedTokenRequestBodyToJSON(
  createReferralsEmbedTokenRequestBody: CreateReferralsEmbedTokenRequestBody,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenRequestBody$outboundSchema.parse(
      createReferralsEmbedTokenRequestBody,
    ),
  );
}

export function createReferralsEmbedTokenRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateReferralsEmbedTokenRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateReferralsEmbedTokenResponseBody$inboundSchema: z.ZodType<
  CreateReferralsEmbedTokenResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  publicToken: z.string(),
  expires: z.string(),
});

/** @internal */
export type CreateReferralsEmbedTokenResponseBody$Outbound = {
  publicToken: string;
  expires: string;
};

/** @internal */
export const CreateReferralsEmbedTokenResponseBody$outboundSchema: z.ZodType<
  CreateReferralsEmbedTokenResponseBody$Outbound,
  z.ZodTypeDef,
  CreateReferralsEmbedTokenResponseBody
> = z.object({
  publicToken: z.string(),
  expires: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateReferralsEmbedTokenResponseBody$ {
  /** @deprecated use `CreateReferralsEmbedTokenResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    CreateReferralsEmbedTokenResponseBody$inboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    CreateReferralsEmbedTokenResponseBody$outboundSchema;
  /** @deprecated use `CreateReferralsEmbedTokenResponseBody$Outbound` instead. */
  export type Outbound = CreateReferralsEmbedTokenResponseBody$Outbound;
}

export function createReferralsEmbedTokenResponseBodyToJSON(
  createReferralsEmbedTokenResponseBody: CreateReferralsEmbedTokenResponseBody,
): string {
  return JSON.stringify(
    CreateReferralsEmbedTokenResponseBody$outboundSchema.parse(
      createReferralsEmbedTokenResponseBody,
    ),
  );
}

export function createReferralsEmbedTokenResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateReferralsEmbedTokenResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateReferralsEmbedTokenResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateReferralsEmbedTokenResponseBody' from JSON`,
  );
}
